<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0" />
        <title>Travis Athougies - Dynamic Programming in Haskell is Just Recursion</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
        <link rel="stylesheet" type="text/css" href="../css/jquery.modal.css" />
        <link href="http://fonts.googleapis.com/css?family=Open+Sans:400,300,800,700" rel="stylesheet" type="text/css">
        <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/javascript" src="../js/jquery.min.js"></script>
        <script type"text javascript" src="../js/jquery.modal.min.js"></script>
	<script type="text/javascript" src="../js/isotope.min.js"></script>
	<script type="text/javascript" src="../js/imagesloaded.min.js"></script>
        <script type="text/javascript" src="../js/gallery.js"></script>
    </head>
    <body>
        <div id="mini-header-bar">
          <div id="show-header">
            ☰
          </div>
          <h1 id="mini-logo">
            <a href="../"><p class="travis">Travis</p><p>Athougies</p></a>
          </h1>
        </div>
        <div id="gallery-modal" class="modal" style="display: hidden">
          <a href="#" id="gallery-prev"></a>
          <a href="#" id="gallery-next"></a>
          <img id="gallery-image" src="#" />
          <div id="gallery-caption">
            <span class="gallery-figure">Figure <span id="figure-number">0</span> &mdash;</span><span id="caption-text"></span>
          </div>
        </div>
        <div id="header">
            <h1 id="logo">
                <a href="../"><p class="travis">Travis</p><p>Athougies</p></a>
            </h1>
            <div id="taglines">
              technologist
              dreamer
              builder
            </div>
            <ul id="navigation">
              <li><h2>Navigation</h2>
                <ul>
                  <li><a href="../">Home</a></li>
                  <li><a href="../about.html">About</a></li>
                  <li><a href="../projects.html">Projects</a></li>
                  <li><a href="../contact.html">Contact</a></li>
                  <li><a href="../archive.html">Archive</a></li>
                </ul></li>
              <li><h2>Tags</h2>
                <ul>
                
                  <li><a href="../tags/haskell.html">haskell (16)</a></li>
                
                  <li><a href="../tags/hydroponics.html">hydroponics (9)</a></li>
                
                  <li><a href="../tags/sustainability.html">sustainability (5)</a></li>
                
                  <li><a href="../tags/gardening.html">gardening (4)</a></li>
                
                  <li><a href="../tags/math.html">math (3)</a></li>
                
                  <li><a href="../tags/beam.html">beam (3)</a></li>
                
                  <li><a href="../tags/web.html">web (2)</a></li>
                
                  <li><a href="../tags/type theory.html">type theory (1)</a></li>
                
                  <li><a href="../tags/physics.html">physics (1)</a></li>
                
                  <li><a href="../tags/hakyll.html">hakyll (1)</a></li>
                
                  <li><a href="../tags/food.html">food (1)</a></li>
                
                  <li><a href="../tags/finance.html">finance (1)</a></li>
                
                  <li><a href="../tags/databases.html">databases (1)</a></li>
                
                  <li><a href="../tags/business.html">business (1)</a></li>
                
                  <li><a href="../tags/agriculture.html">agriculture (1)</a></li>
                
                  <li><a href="../tags/HoTT.html">HoTT (1)</a></li>
                </ul></li>
            </ul>
          <div id="shamelessplug">
              Site proudly generated by
              <a href="http://jaspervdj.be/hakyll">Hakyll</a> <p></p>
              This site kept updated by <a href="http://travis-ci.org">Travis CI</a> <p></p>
              <img src="https://travis-ci.org/tathougies/travis-athougies-blog.svg?branch=master" />
          </div>
        </div>

        <div id="content">
            <h1>Dynamic Programming in Haskell is Just Recursion</h1>

            <div class="info">
    Posted on <span class="date">May  5, 2018</span>
    
        by <span class="author">Travis Athougies</span>
    
</div>
<div class="tags">
  in
  <ul>
    
    <li><a href="../tags/haskell.html">haskell</a></li>
    
  </ul>
</div>



<div id="post">
<p>One question I have often been asked when it comes to Haskell is ‘how
do I do dynamic programming?’.</p>
<p>For those of you unfamiliar, <a href="https://en.wikipedia.org/wiki/Dynamic_programming">dynamic
programming</a> is an
algorithmic technique where you solve a problem by building up some
kind of intermediate data structure to reduce redundant work. This can
sometimes turn exponential-time algorithms into polynomial-time ones.</p>
<p>One classical example of a problem requiring dynamic programming for
manageable run-times is the longest common subsequence problem. This
problem takes two inputs <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>, and returns the length of the
longest subsequence of elements in both <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>. Recall that a
subsequence <span class="math inline">\(L\)</span> of a sequence <span class="math inline">\(S\)</span> is a sequence of items
<span class="math inline">\(\{s_{i_0},s_{i_1},\ldots,s_{i_n}\}\)</span> where each <span class="math inline">\(s_{i_n} \in S\)</span> and
<span class="math inline">\(i_{m+1} &gt; i_m\)</span> for all <span class="math inline">\(m \in \{i_0, \ldots, i_n\}\)</span>. This differs
from the longest common substring problem (a trivially polynomial
algorithm) in that the items in <span class="math inline">\(L\)</span> need not be contiguous in <span class="math inline">\(S\)</span>.</p>
<p>For example, the longest common subsequence of <code>"babba"</code> and <code>"abca"</code>
is <code>"aba"</code>, so our algorithm should return 3.</p>
<p>In an imperative programming language like C, a naïve programming
solution might be <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">/* Returns length of LCS for X[0..m-1], Y[0..n-1] */</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> lcs<span class="op">(</span> <span class="dt">char</span> <span class="op">*</span>X<span class="op">,</span> <span class="dt">char</span> <span class="op">*</span>Y<span class="op">,</span> <span class="dt">int</span> m<span class="op">,</span> <span class="dt">int</span> n <span class="op">)</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>   <span class="cf">if</span> <span class="op">(</span>m <span class="op">==</span> <span class="dv">0</span> <span class="op">||</span> n <span class="op">==</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>     <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>   <span class="cf">if</span> <span class="op">(</span>X<span class="op">[</span>m<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">==</span> Y<span class="op">[</span>n<span class="op">-</span><span class="dv">1</span><span class="op">])</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>     <span class="cf">return</span> <span class="dv">1</span> <span class="op">+</span> lcs<span class="op">(</span>X<span class="op">,</span> Y<span class="op">,</span> m<span class="op">-</span><span class="dv">1</span><span class="op">,</span> n<span class="op">-</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>   <span class="cf">else</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>     <span class="cf">return</span> max<span class="op">(</span>lcs<span class="op">(</span>X<span class="op">,</span> Y<span class="op">,</span> m<span class="op">,</span> n<span class="op">-</span><span class="dv">1</span><span class="op">),</span> lcs<span class="op">(</span>X<span class="op">,</span> Y<span class="op">,</span> m<span class="op">-</span><span class="dv">1</span><span class="op">,</span> n<span class="op">));</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>We can write a similar implementation in Haskell. Instead of iterating
backwards, we’ll iterate forwards.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">naiveLCS ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>naiveLCS [] _ <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>naiveLCS _ [] <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>naiveLCS (x<span class="op">:</span>xs) (y<span class="op">:</span>ys)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> x <span class="op">==</span> y    <span class="ot">=</span> <span class="dv">1</span> <span class="op">+</span> naiveLCS xs ys</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="fu">max</span> (naiveLCS (x<span class="op">:</span>xs) ys) (naiveLCS xs (y<span class="op">:</span>ys))</span></code></pre></div>
<p>These implementations both have a runtime of <span class="math inline">\(O\left( n 2^m \right)\)</span>
given inputs of length <span class="math inline">\(m\)</span> and <span class="math inline">\(n\)</span>.</p>
<p>This post is Literate Haskell. You can download this
<a href="https://github.com/tathougies/travis-athougies-blog/blob/master/site-content/posts/2018-05-05-dynamic-programming-is-recursion.lhs">file</a>
and load it into GHCi without modification. If we evaluate <code>naiveLCS</code> with
our first example, we get the answer fairly quickly:</p>
<pre class="console"><code>*Main&gt; naiveLCS &quot;babba&quot; &quot;abca&quot;
3</code></pre>
<p>Let’s try to execute <code>naiveLCS</code> in GHCi with some larger inputs:</p>
<pre class="console"><code>*Main&gt; naiveLCS &quot;nematode knowledge&quot; &quot;empty bottle&quot;
7</code></pre>
<p>Prepare to wait a while for the answer.</p>
<p>One way to speed things up is to note that we end up recursing on the
same values over and over again. If we computed the results of the
calls before they were needed, then we would not need to recompute
them.</p>
<p>In C, this caching is straightforward. We just create an array to hold
recursive steps we’ve already computed. If we ensure that our values
are always computed before we need them, then we don’t even need to
recurse <a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> lcs<span class="op">(</span> <span class="dt">char</span> <span class="op">*</span>X<span class="op">,</span> <span class="dt">char</span> <span class="op">*</span>Y<span class="op">,</span> <span class="dt">int</span> m<span class="op">,</span> <span class="dt">int</span> n <span class="op">)</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>   <span class="dt">int</span> L<span class="op">[</span>m<span class="op">+</span><span class="dv">1</span><span class="op">][</span>n<span class="op">+</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>   <span class="dt">int</span> i<span class="op">,</span> j<span class="op">;</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>   <span class="co">/* Following steps build L[m+1][n+1] in bottom up fashion. Note</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="co">      that L[i][j] contains length of LCS of X[0..i-1] and Y[0..j-1] */</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>   <span class="cf">for</span> <span class="op">(</span>i<span class="op">=</span><span class="dv">0</span><span class="op">;</span> i<span class="op">&lt;=</span>m<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>   <span class="op">{</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>     <span class="cf">for</span> <span class="op">(</span>j<span class="op">=</span><span class="dv">0</span><span class="op">;</span> j<span class="op">&lt;=</span>n<span class="op">;</span> j<span class="op">++)</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>     <span class="op">{</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>       <span class="cf">if</span> <span class="op">(</span>i <span class="op">==</span> <span class="dv">0</span> <span class="op">||</span> j <span class="op">==</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>         L<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>       <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>X<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">==</span> Y<span class="op">[</span>j<span class="op">-</span><span class="dv">1</span><span class="op">])</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>         L<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> L<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>       <span class="cf">else</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>         L<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> max<span class="op">(</span>L<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>j<span class="op">],</span> L<span class="op">[</span>i<span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>     <span class="op">}</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>   <span class="op">}</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>   <span class="co">/* L[m][n] contains length of LCS for X[0..n-1] and Y[0..m-1] */</span></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>   <span class="cf">return</span> L<span class="op">[</span>m<span class="op">][</span>n<span class="op">];</span></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The run-time of this algorithm is <span class="math inline">\(O\left(mn\right)\)</span> where <span class="math inline">\(m\)</span> and <span class="math inline">\(n\)</span>
are the sizes of the input strings.</p>
<p>This approach works well in imperative languages where in-place
mutation is explicit. Of course, you can simulate the same kind of
thing in Haskell with the <code>IO</code> or <code>ST</code> monad and the <code>array</code> package,
but this seems inelegant. After all, the LCS function is a pure
function – we ought to be able to craft a pure and efficient
implementation.</p>
<p>It may seem like a major embarrassment that a functional language
can’t implement this seemingly trivial function without exploding in
computation time or demanding that we provide explicit, effectful
instructions on how to mutate bits.</p>
<p>However, this conclusion is premature. Dynamic programming is no more
difficult to implement in Haskell than in C. In fact, dynamic
programming in Haskell seems trivially simple, because it takes the
form of regular old Haskell recursion.</p>
<h2 id="mutation-is-everywhere">Mutation is everywhere</h2>
<p>In Haskell, all functions are pure – their value is determined solely
by their inputs. It is entirely possible to cache the values of
Haskell functions to avoid recomputation. However, GHC and other
popular Haskell compilers do not do this by default (see the
<a href="https://hackage.haskell.org/package/MemoTrie"><code>MemoTrie</code></a> package for
a way to convince them to do so).</p>
<p>However, all Haskell compilers perform one particular kind of
caching. If we have a variable binding of the form</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x <span class="ot">=</span> f a b c</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span> g x x x</span></code></pre></div>
<p>then <code>x</code> is only computed once, each time it is used in <code>g</code>. This is
due to Haskell’s laziness. Internally, the expression <code>g x x x</code>
results in an unevaluated thunk, where each instance of <code>x</code> points to
the same unevaluated thunk <code>f a b c</code>. When <code>x</code> is demanded once in
<code>g</code>, the thunk is computed, and future evaluations of the thunk
pointed to by <code>x</code> simply use the cached value. This is demonstrated in
the figure below.</p>
<figure>
<div class="figure figure-centered"><a href="../images/mmm/heaplayoutf.png"><img src="../images/mmm/heaplayoutf.png" alt=" The heap layout of the expression &lt;code&gt;let x = f a b c in g  x x x&lt;/code&gt;. Notice how each occurrence of &lt;code&gt;x&lt;/code&gt; in the invocation of &lt;code&gt;g&lt;/code&gt;
points to the same thunk for &lt;code&gt;f&lt;/code&gt;." width="auto"></a><p class="caption"> The heap layout of the expression <code>let x = f a b c in g  x x x</code>. Notice how each occurrence of <code>x</code> in the invocation of <code>g</code>
points to the same thunk for <code>f</code>.</p></div>
<figcaption><del>CENTERED</del> The heap layout of the expression <code>let x = f a b c in g  x x x</code>. Notice how each occurrence of <code>x</code> in the invocation of <code>g</code>
points to the same thunk for <code>f</code>.</figcaption>
</figure>
<p>This feature is called ‘sharing’. You may think this sounds
suspiciously like mutation in a pure language, and you’d be absolutely
right. Contrary to popular belief, mutation is prevalent during the
execution of any Haskell program. In fact, it’s integral to the
language. The difference is that mutation is controlled, and while a
mutation may change the value in a certain memory cell, it never
changes its semantics. This is known as <em>referential transparency</em>.</p>
<p>We can use this technique to cache values. A common example of this is
the one-line Fibonacci many Haskell beginners encounter. Firstly, the
naive Fibonacci function. This has complexity <span class="math inline">\(O(\phi^n)\)</span>, where
<span class="math inline">\(\phi\)</span> is the golden ratio.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">naiveFib ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>naiveFib <span class="dv">0</span> <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>naiveFib <span class="dv">1</span> <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>naiveFib n <span class="ot">=</span> naiveFib (n <span class="op">-</span> <span class="dv">1</span>) <span class="op">*</span> naiveFib (n <span class="op">-</span> <span class="dv">2</span>)</span></code></pre></div>
<p>The one-line solution uses a lazy list to represent all Fibonacci
numbers, and then list lookups to compute the <span class="math inline">\(n^{\text{th}}\)</span>
number.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">linearFib ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>linearFib n <span class="ot">=</span> <span class="kw">let</span> fibs <span class="ot">=</span> <span class="dv">0</span><span class="op">:</span><span class="dv">1</span><span class="op">:</span><span class="fu">zipWith</span> (<span class="op">+</span>) fibs (<span class="fu">tail</span> fibs)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>              <span class="kw">in</span> fibs <span class="op">!!</span> n</span></code></pre></div>
<p>Note that, aside from the first two entries, each entry depends on the
values of the entry <em>computed within the list</em>, as illustrated below.</p>
<figure>
<div class="figure figure-centered"><a href="../images/mmm/fibdeps.png"><img src="../images/mmm/fibdeps.png" alt=" Dependencies for the fibonnaci ‘one-liner’. When we
evaluate &lt;code&gt;fibs !! 4&lt;/code&gt;, we get a reference to a thunk that depends on
other thunks in the &lt;code&gt;fibs&lt;/code&gt; list. This causes each thunk to only be
computed once." width="auto"></a><p class="caption"> Dependencies for the fibonnaci ‘one-liner’. When we
evaluate <code>fibs !! 4</code>, we get a reference to a thunk that depends on
other thunks in the <code>fibs</code> list. This causes each thunk to only be
computed once.</p></div>
<figcaption><del>CENTERED</del> Dependencies for the fibonnaci ‘one-liner’. When we
evaluate <code>fibs !! 4</code>, we get a reference to a thunk that depends on
other thunks in the <code>fibs</code> list. This causes each thunk to only be
computed once.</figcaption>
</figure>
<p>When we compute <code>fibs !! 4</code>, we get a reference for a thunk that has
yet to be computed. When we force the value, each referenced cell is
computed, but never more than once. Thus, the time complexity of
<code>linearFib</code> is simply <code>O(n)</code>.</p>
<h2 id="finding-subsequences">Finding subsequences</h2>
<p>We can apply the exact same optimization to the
longest-common-subequence as the Fibonacci problem. The data flow is a
bit harder to visualize, because the LCS problem uses a
‘two-dimensional’ data structure to hold unevaluated thunks.</p>
<p>In this case, we’re going to go with the most obvious solution. This
solution isn’t going to be as fast as an optimized one, but it will
have the correct <span class="math inline">\(O(mn)\)</span> complexity.</p>
<p>First, let’s write our function signature and a simple case if one of
the strings is empty.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">dpLCS ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>dpLCS _ [] <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>dpLCS a b <span class="ot">=</span></span></code></pre></div>
<p>Looking at the C solution, we can demonstrate how each entry in the
array depends on others. Note that each entry depends only on the
entries to the left, directly above, and diagonal top-left, as
illustrated in the diagram below. Notice also how each column
corresponds to a specific index into the second string, and each row
to a specific index in the first.</p>
<figure>
<div class="figure figure-centered"><a href="../images/mmm/tbldeps.png"><img src="../images/mmm/tbldeps.png" alt="  The table built up by the imperative
algorithm for the inputs “nematode knowledge” and “empty bottle”. The
arrows point to cells that were necessary to compute the cell they
originate from. Dark arrows represent dependencies actually used to
compute this cell. Red boxes are cells where we added one because the
corresponding characters matched." width="400px"></a><p class="caption">  The table built up by the imperative
algorithm for the inputs “nematode knowledge” and “empty bottle”. The
arrows point to cells that were necessary to compute the cell they
originate from. Dark arrows represent dependencies actually used to
compute this cell. Red boxes are cells where we added one because the
corresponding characters matched.</p></div>
<figcaption><del>CENTERED</del> <del>WIDTH:400px</del> The table built up by the imperative
algorithm for the inputs “nematode knowledge” and “empty bottle”. The
arrows point to cells that were necessary to compute the cell they
originate from. Dark arrows represent dependencies actually used to
compute this cell. Red boxes are cells where we added one because the
corresponding characters matched.</figcaption>
</figure>
<p>With that in mind, we can construct a function to construct a row in
this table, given the row directly above and the character in the
first string being considered.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> nextRow ac prevRow <span class="ot">=</span></span></code></pre></div>
<p>To keep the computation of each entry orthogonal, notice that we can
think of the entries on the left and upper edges as being computed the
same as every other entry, except with zeros in the diagonal and left
or upper entries respectively. These ‘phantom’ nodes are illustrated
below.</p>
<p>With that in mind, we can construct a list of elements on the
diagonal. The diagonal entry used to calculate the first element is
simply zero. For the second element, it’s the first element in the row
above; for the third, the second; etc.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>         <span class="kw">let</span> diagonals <span class="ot">=</span> <span class="dv">0</span><span class="op">:</span>prevRow</span></code></pre></div>
<p>We can also construct a list for elements to the left. The element to
the left of the first is simply zero. The element to the left of the
second is the first, etc.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>             lefts <span class="ot">=</span> <span class="dv">0</span><span class="op">:</span>thisRow</span></code></pre></div>
<p>Above, <code>thisRow</code> corresponds to the final value of this row, which has
yet to be computed. This is where the caching magic takes place.</p>
<p>Finally, the elements directly above is simply the previous row.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>             ups <span class="ot">=</span> prevRow</span></code></pre></div>
<p>Now, we only care about the max of the solution to the left and the
solution above, so we can construct a list of <code>max</code>es we care about.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>             maxes <span class="ot">=</span> <span class="fu">zipWith</span> <span class="fu">max</span> lefts ups</span></code></pre></div>
<p>Now, we can compute this row, by simply combining these maxes with the
diagonal values and the character corresponding to the column.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>             thisRow <span class="ot">=</span> <span class="fu">zipWith3</span> (\diag maxLeftUp bc <span class="ot">-&gt;</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>                                   <span class="kw">if</span> bc <span class="op">==</span> ac <span class="kw">then</span> <span class="dv">1</span> <span class="op">+</span> diag <span class="kw">else</span> maxLeftUp)</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>                                   diagonals maxes b</span></code></pre></div>
<p>Finally, we need to return the value of <code>thisRow</code>.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>        <span class="kw">in</span> thisRow</span></code></pre></div>
<p>Now, we can construct our entire table, keeping in mind that the
‘previous row’ corresponding to the first row, is simply the row
containing all zeros.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>      firstRow <span class="ot">=</span> <span class="fu">map</span> (\_ <span class="ot">-&gt;</span> <span class="dv">0</span>) b</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>      dpTable <span class="ot">=</span> firstRow<span class="op">:</span><span class="fu">zipWith</span> nextRow a dpTable</span></code></pre></div>
<p>Now, the actual value we’re interested in is simply the very last
element of the very last list. We can just use Haskell’s <code>last</code>
function to get this value. Because of our initial check, this usage
is safe.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span> <span class="fu">last</span> (<span class="fu">last</span> dpTable)</span></code></pre></div>
<p>Now, if we run <code>dpLCS</code> on our little problem, we get the answer instantaneously.</p>
<pre class="console"><code>*Main&gt; dpLCS &quot;nematode knowledge&quot; &quot;empty bottle&quot;
7</code></pre>
<p>For clarity’s sake, the complete implementation of <code>dpLCS</code> is given below:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="ot">dpLCS ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>dpLCS _ [] <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>dpLCS a b <span class="ot">=</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> nextRow ac prevRow <span class="ot">=</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> diagonals <span class="ot">=</span> <span class="dv">0</span><span class="op">:</span>prevRow</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>            lefts <span class="ot">=</span> <span class="dv">0</span><span class="op">:</span>thisRow</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>            ups <span class="ot">=</span> prevRow</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>            maxes <span class="ot">=</span> <span class="fu">zipWith</span> <span class="fu">max</span> lefts ups</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>            thisRow <span class="ot">=</span> <span class="fu">zipWith3</span> (\diag maxLeftUp bc <span class="ot">-&gt;</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>                                   <span class="kw">if</span> bc <span class="op">==</span> ac <span class="kw">then</span> <span class="dv">1</span> <span class="op">+</span> diag <span class="kw">else</span> maxLeftUp)</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>                                   diagonals maxes b</span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">in</span> thisRow</span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a>      firstRow <span class="ot">=</span> <span class="fu">map</span> (\_ <span class="ot">-&gt;</span> <span class="dv">0</span>) b</span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>      dpTable <span class="ot">=</span> firstRow<span class="op">:</span><span class="fu">zipWith</span> nextRow a dpTable</span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span> <span class="fu">last</span> (<span class="fu">last</span> dpTable)</span></code></pre></div>
<h2 id="discussion">Discussion</h2>
<p>The solution above has the right complexity, but is quite
inefficient. While it exploits laziness to avoid recomputation, it is
too lazy in some respects. In a future post, we’ll see how to
control Haskell’s sharing to get performance we need. We’ll also see
that Haskell’s approach to these problems gives us some important
memory properties for free.</p>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>Taken from https://www.geeksforgeeks.org/longest-common-subsequence/<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>Taken from https://www.geeksforgeeks.org/longest-common-subsequence/<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</div>

<div id="disqus_thread"></div>
<script type="text/javascript">
/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
var disqus_shortname = 'travisathougiessblog'; // required: replace example with your forum shortname

/* * * DON'T EDIT BELOW THIS LINE * * */
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

        </div>
        <!-- Google Analytics Tracking -->
        <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-55204994-1', 'auto');
        ga('send', 'pageview');

        </script>
    </body>
</html>
