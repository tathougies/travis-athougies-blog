<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0" />
        <title>Travis Athougies - FRP made simple!</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
        <link rel="stylesheet" type="text/css" href="../css/jquery.modal.css" />
        <link href="http://fonts.googleapis.com/css?family=Open+Sans:400,300,800,700" rel="stylesheet" type="text/css">
        <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/javascript" src="../js/jquery.min.js"></script>
        <script type"text javascript" src="../js/jquery.modal.min.js"></script>
	<script type="text/javascript" src="../js/isotope.min.js"></script>
	<script type="text/javascript" src="../js/imagesloaded.min.js"></script>
        <script type="text/javascript" src="../js/gallery.js"></script>
    </head>
    <body>
        <div id="mini-header-bar">
          <div id="show-header">
            ☰
          </div>
          <h1 id="mini-logo">
            <a href="../"><p class="travis">Travis</p><p>Athougies</p></a>
          </h1>
        </div>
        <div id="gallery-modal" class="modal" style="display: hidden">
          <a href="#" id="gallery-prev"></a>
          <a href="#" id="gallery-next"></a>
          <img id="gallery-image" src="#" />
          <div id="gallery-caption">
            <span class="gallery-figure">Figure <span id="figure-number">0</span> &mdash;</span><span id="caption-text"></span>
          </div>
        </div>
        <div id="header">
            <h1 id="logo">
                <a href="../"><p class="travis">Travis</p><p>Athougies</p></a>
            </h1>
            <div id="taglines">
              technologist
              dreamer
              builder
            </div>
            <ul id="navigation">
              <li><h2>Navigation</h2>
                <ul>
                  <li><a href="../">Home</a></li>
                  <li><a href="../about.html">About</a></li>
                  <li><a href="../projects.html">Projects</a></li>
                  <li><a href="../contact.html">Contact</a></li>
                  <li><a href="../archive.html">Archive</a></li>
                </ul></li>
              <li><h2>Tags</h2>
                <ul>
                
                  <li><a href="../tags/haskell.html">haskell (16)</a></li>
                
                  <li><a href="../tags/hydroponics.html">hydroponics (9)</a></li>
                
                  <li><a href="../tags/sustainability.html">sustainability (5)</a></li>
                
                  <li><a href="../tags/gardening.html">gardening (4)</a></li>
                
                  <li><a href="../tags/math.html">math (3)</a></li>
                
                  <li><a href="../tags/beam.html">beam (3)</a></li>
                
                  <li><a href="../tags/ai.html">ai (3)</a></li>
                
                  <li><a href="../tags/web.html">web (2)</a></li>
                
                  <li><a href="../tags/type theory.html">type theory (1)</a></li>
                
                  <li><a href="../tags/physics.html">physics (1)</a></li>
                
                  <li><a href="../tags/hakyll.html">hakyll (1)</a></li>
                
                  <li><a href="../tags/food.html">food (1)</a></li>
                
                  <li><a href="../tags/finance.html">finance (1)</a></li>
                
                  <li><a href="../tags/ethics.html">ethics (1)</a></li>
                
                  <li><a href="../tags/databases.html">databases (1)</a></li>
                
                  <li><a href="../tags/business.html">business (1)</a></li>
                
                  <li><a href="../tags/agriculture.html">agriculture (1)</a></li>
                
                  <li><a href="../tags/HoTT.html">HoTT (1)</a></li>
                </ul></li>
            </ul>
          <div id="shamelessplug">
              Site proudly generated by
              <a href="http://jaspervdj.be/hakyll">Hakyll</a> <p></p>
              This site kept updated by <a href="http://travis-ci.org">Travis CI</a> <p></p>
              <img src="https://travis-ci.org/tathougies/travis-athougies-blog.svg?branch=master" />
          </div>
        </div>

        <div id="content">
            <h1>FRP made simple!</h1>

            <div class="info">
    Posted on <span class="date">May  5, 2015</span>
    
        by <span class="author">Travis Athougies</span>
    
</div>
<div class="tags">
  in
  <ul>
    
    <li><a href="../tags/haskell.html">haskell</a></li>
    
  </ul>
</div>



<div id="post">
<p>Functional Reactive Programming refers to a declarative way to write eventful program in functional
languages like Haskell. While the concepts behind FRP are straightforward to grasp, the actual
implementations are not.</p>
<p>Libraries like sodium, reactive-banana, elerea, and yampa share one thing in common: large code
bases that are not easily understood by beginners. In this blog post, I will develop a sodium-like
FRP implementation for Haskell in under 200 lines. Note that this is possible by eschewing any
concerns over performance or memory usage, so this library would probably not be practical to use in
any live code.</p>
<h2 id="a-brief-recap-of-frp">A brief recap of FRP</h2>
<p>FRP libraries usually consist of two primitives: <code>Event</code> and <code>Behavior</code>. An <code>Event</code> refers to values
which only occur at certain times, and which are lost after the moment they occur. You can think of
an <code>Event a</code> as a list of pairs of times <code>t</code> and values <code>a</code>: <code>[(t, a)]</code>. A <code>Behavior</code> is a
continuous value. Here, continuous means that a <code>Behavior</code> has a defined value for any given time
(not the mathematical definition!). We can think of a <code>Behavior a</code> as a function from a time <code>t</code> to
the value <code>a</code>.</p>
<h2 id="first-steps">First steps</h2>
<p>The first thing we will do is define a monad for all of our FRP computations. Our FRP implementation
will also allow us to execute arbitrary <code>IO</code> actions in response to events (much like the <code>execute</code>
primitive in Sodium), so we will need a separate monad to represent what happens “in the moment.”
Right now, we’ll just make both of these monads aliases for <code>IO</code>.</p>
<p>Also, before we start, the final library we will end up writing is available on <a href="https://github.com/tathougies/react.hs">GitHub.</a></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">React</span> <span class="ot">=</span> <span class="dt">IO</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Moment</span> <span class="ot">=</span> <span class="dt">IO</span></span></code></pre></div>
<p>In many FRP implementations, <code>Behavior</code> actually isn’t anything more than a step function whose
value can only be updated by events. Therefore, we’ll start by defining our <code>Event</code> type. The only
really important thing about events is that we be able to subscribe and unsubscibe from them.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">RegisterEventListener</span> a <span class="ot">=</span> (a <span class="ot">-&gt;</span> <span class="dt">Moment</span> ()) <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">IO</span> ())</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Event</span> a <span class="ot">=</span> <span class="dt">Event</span> {<span class="ot"> _eventRegisterListener ::</span> <span class="dt">RegisterEventListener</span> a }</span></code></pre></div>
<p>First, we define the <code>RegisterEventListener</code> type. Functions of this type can be used to register a
function in the <code>Moment</code> monad which will be called whenever a new value (of type <code>a</code>) of the event
is produced. The listener must be registered in the <code>IO</code> monad, and the registration function
returns another monadic action of type <code>IO ()</code>. This function is used to deregister the listener
that has been added.</p>
<p><code>Event a</code> fills the requirements for both a <code>Monoid</code> and a <code>Functor</code>. For the <code>Monoid</code> instance,
<code>mempty</code> is the Event that never fires, and <code>mappend</code> takes two <code>Event a</code>’s and returns a new <code>Event a</code> that fires whenever either of the first two fires.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monoid</span> (<span class="dt">Event</span> a) <span class="kw">where</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mempty</span> <span class="ot">=</span> never</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mappend</span> <span class="ot">=</span> merge</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="ot">never ::</span> <span class="dt">Event</span> a</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>never <span class="ot">=</span> <span class="dt">Event</span> (\_ <span class="ot">-&gt;</span> <span class="fu">return</span> (<span class="fu">return</span> ()))</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="ot">merge ::</span> <span class="dt">Event</span> a <span class="ot">-&gt;</span> <span class="dt">Event</span> a <span class="ot">-&gt;</span> <span class="dt">Event</span> a</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>merge a b <span class="ot">=</span> <span class="dt">Event</span> (\listener <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>                     unregisterA <span class="ot">&lt;-</span> _eventRegisterListener a listener</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>                     unregisterB <span class="ot">&lt;-</span> _eventRegisterListener b listener</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>                     <span class="fu">return</span> (unregisterA <span class="op">&gt;&gt;</span> unregisterB))</span></code></pre></div>
<p>Let’s look at each function individually. First, let’s consider the <code>mempty</code> or <code>never</code>
functions. Whenever a listener tries to register with this event, the listener is totally ignored
and the deregistration function returned does nothing. This means that the listener will never be
called (i.e., the event will never fire), which is the behavior we wanted.</p>
<p>The <code>mappend</code> or <code>merge</code> function take two events and returns a new one. When a listener tries to
register with the new event, the listener is in fact registered with both events. Thus, the listener
will be called whenever either <code>a</code> or <code>b</code> fire, which is the behavior we wanted. The deregistration
function deregisters the listener from both <code>a</code> and <code>b</code>.</p>
<p>Now for the <code>Functor</code> instance. The <code>Functor</code> instance for event allows us to apply functions to the
value contained inside an event in order to a get a new dependent event. I’ve included a type
signature to remind the reader of the type of the <code>fmap</code> function for <code>Event</code>’s.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Event</span> <span class="kw">where</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Event</span> a <span class="ot">-&gt;</span> <span class="dt">Event</span> b</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> f eb <span class="ot">=</span> <span class="dt">Event</span> (\listener <span class="ot">-&gt;</span> _eventRegisterListener eb (listener <span class="op">.</span> f))</span></code></pre></div>
<p>In <code>fmap</code>, we translate our listening function to be able to listen to the original event, and then
subscribe it to that. Recall that <code>eb</code> has type <code>Event b</code>, so <code>_eventRegisterListener eb</code> has type
<code>(b -&gt; Moment ()) -&gt; IO (IO ())</code>. The <code>listener</code> function we’ve been supplied has type <code>a -&gt; Moment ()</code>, but <code>listener . f</code> has type <code>b -&gt; Moment()</code>, so we can use it as the new listener for <code>eb</code>.</p>
<h2 id="getting-behaviors-to-behave">Getting behaviors to behave</h2>
<p>As we said before, although we can think of <code>Behavior</code>s as continuous-time properties, in reality,
our FRP implementation will treat them as stepper functions that must be updated by an
event. Therefore, every <code>Behavior</code> will need to be tied with an event that will fire whenever the
behavior is updated. Secondly, although the value of <code>Behavior</code> is impure (it changes through time),
its value is well defined given a point in time. Therefore, we should be able to access it through
<code>Moment</code>. Thus, our <code>Behavior</code> type will also have to support a way to get at its current value.</p>
<p>It’s easy to combine these requirements into a <code>Behavior</code> data type, which consists of an event
which fires on updates and a function to get the current value.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Behavior</span> a <span class="ot">=</span> <span class="dt">Behavior</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>                {<span class="ot"> _behaviorUpdates ::</span> <span class="dt">Event</span> ()</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>                ,<span class="ot"> _behaviorGetValue ::</span> <span class="dt">Moment</span> a }</span></code></pre></div>
<p>It turns out that <code>Behavior</code> is an <code>Applicative</code>. The <code>pure</code> function for <code>Behavior</code> will return a
<code>Behavior</code> whose value does not change in time. The <code>(&lt;*&gt;)</code> function will return a <code>Behavior</code> whose
value at any given point in time is the current value of the first <code>Behavior</code> applied to the current
value of the second. I’ve included type signatures for convenience.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Applicative</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Behavior</span> <span class="kw">where</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  pure ::</span> a <span class="ot">-&gt;</span> <span class="dt">Behavior</span> a</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> a <span class="ot">=</span> <span class="dt">Behavior</span> { _behaviorUpdates <span class="ot">=</span> <span class="fu">mempty</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>                    , _behaviorGetValue <span class="ot">=</span> <span class="fu">return</span> a}</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="ot">  (&lt;*&gt;) ::</span> <span class="dt">Behavior</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Behavior</span> a <span class="ot">-&gt;</span> <span class="dt">Behavior</span> b</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>  bab <span class="op">&lt;*&gt;</span> ba <span class="ot">=</span> <span class="dt">Behavior</span> { _behaviorUpdates <span class="ot">=</span> _behaviorUpdates bab <span class="op">&lt;&gt;</span> _behaviorUpdates ba</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>                        , _behaviorGetValue <span class="ot">=</span> <span class="kw">do</span> ab <span class="ot">&lt;-</span> _behaviorGetValue bab</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>                                                 a <span class="ot">&lt;-</span> _behaviorGetValue ba</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>                                                 <span class="fu">return</span> (ab a) }</span></code></pre></div>
<p>The <code>Behavior</code> returned by <code>pure a</code> is a <code>Behavior</code> that never updates (i.e., is constant) and whose
value always returns <code>a</code>. This fulfills our requirements for a constant <code>Behavior</code>.</p>
<p>The <code>Behavior</code> returned by <code>f &lt;*&gt; a</code> is a <code>Behavior</code> who updates whenever <code>f</code> or <code>a</code> update, and
whose value is the value of <code>f</code> applied to the value of <code>a</code>.</p>
<h2 id="interfacing-with-the-real-world">Interfacing with the real world</h2>
<p>So now we have <code>Event</code> and <code>Behavior</code> data type and methods to combine them with other <code>Event</code>’s and
<code>Behavior</code>’s respectively. What we don’t have is any way to make an <code>Event</code> that actually fires, or
a <code>Behavior</code> that is not built from other <code>Behavior</code>’s. Let’s implement this functionality to make
our library actually useful.</p>
<h3 id="putting-the-r-in-frp">Putting the ‘R’ in FRP</h3>
<p>Most FRP implementations offer the user a way to create an event as well as an IO (or equivalent)
function that can be used to trigger that event. Our library is no different. Let’s define a
<code>newEvent</code> function which will return a new <code>Event</code> as well as a function to trigger our <code>Event</code>.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.Trans</span> <span class="co">-- for `liftIO`</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">M</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Unique</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.IORef</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="ot">newEvent ::</span> <span class="dt">React</span> (<span class="dt">Event</span> a, a <span class="ot">-&gt;</span> <span class="dt">Moment</span> ())</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>newEvent <span class="ot">=</span> <span class="kw">do</span> (registerListener, propagateListeners) <span class="ot">&lt;-</span> newEventRegistration</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>              <span class="fu">return</span> (<span class="dt">Event</span> registerListener, propagateListeners)</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a><span class="ot">newEventRegistration ::</span> <span class="dt">React</span> (<span class="dt">RegisterEventListener</span> a, a <span class="ot">-&gt;</span> <span class="dt">Moment</span> ())</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>newEventRegistration <span class="ot">=</span> <span class="kw">do</span> listeners <span class="ot">&lt;-</span> newIORef M.empty</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>                          <span class="kw">let</span> registerListener listener <span class="ot">=</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>                                <span class="kw">do</span> listenerKey <span class="ot">&lt;-</span> newUnique</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>                                   modifyIORef listeners (M.insert listenerKey listener)</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>                                   <span class="fu">return</span> (modifyIORef listeners (M.delete listenerKey)</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>                              propagateListeners x <span class="ot">=</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>                                <span class="kw">do</span> listeners' <span class="ot">&lt;-</span> M.elems <span class="op">&lt;$&gt;</span> liftIO (readIORef listeners)</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>                                   <span class="fu">mapM_</span> (<span class="op">$</span> x) listeners'</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>                          <span class="fu">return</span> (registerListener, propagateListeners)</span></code></pre></div>
<p>I won’t go into all the details here, but basically, the sausage is made in the
<code>newEventRegistration</code> function which uses an <code>IORef</code> to keep track of registered listeners and a
<code>Unique</code> from the <code>Data.Unique</code> library to give each listener a unique key, which is useful for the
deregistration function.</p>
<h3 id="hold-your-horses">Hold your horses!</h3>
<p>So now we can make an <code>Event</code> that we can fire by simply calling a function, but how do we make a
<code>Behavior</code>? Simple! Since <code>Behavior</code>’s are just steppers updated by events, we’ll write a function
that will take an <code>Event a</code> and give us a <code>Behavior a</code>. However, because the <code>Event a</code> might not
fire immediately, we’ll need to give the <code>Behavior a</code> an initial <code>a</code> to hold in the mean-time.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.Mem.Weak</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="ot">hold ::</span> a <span class="ot">-&gt;</span> <span class="dt">Event</span> a <span class="ot">-&gt;</span> <span class="dt">React</span> (<span class="dt">Behavior</span> a)</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>hold initial updates <span class="ot">=</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">do</span> cell <span class="ot">&lt;-</span> newIORef initial</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>     <span class="kw">let</span> behavior <span class="ot">=</span> <span class="dt">Behavior</span> { _behaviorUpdates <span class="ot">=</span> () <span class="op">&lt;$</span> updates</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>                             , _behaviorGetValue <span class="ot">=</span> liftIO (readIORef cell) }</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>     unregisterUpdates <span class="ot">&lt;-</span> _eventRegisterListener updates (\x <span class="ot">-&gt;</span> writeIORef cell x)</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>     addFinalizer behavior unregisterUpdates</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>     <span class="fu">return</span> behavior</span></code></pre></div>
<p>Again, I won’t go into too much detail here, but basically we create an <code>IORef</code> to store the current
value of the behavior, which we read out in the sampling function. The behavior updates event is
made by creating an <code>Event ()</code> from the <code>Event a</code> supplied to us (i.e., the behavior will update
whenever the event does). The <code>(&lt;$)</code> function is given to us for free by virtue of <code>Event</code> being a
<code>Functor</code>. Finally, we register a listener for updates to the updating event, and update the cell
appropriately. We use the <code>addFinalizer</code> function from <code>System.Mem.Weak</code> to automatically unregister
our listener when <code>behavior</code> is garbage collected.</p>
<p>There is one more consideration that we’re not taking into account here. Because we write to the
<code>IORef</code> immediately in the listener, it is possible that sampling the behavior at different points
in the <code>Moment</code> monad will give us different results. This is not what we want since a computation
in the moment monad should semantically run “at the same time.” What we really want is for the cell
to be written after the current moment is complete. We can do this by updating our definition of the
<code>Moment</code> monad.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.Writer</span> <span class="kw">hiding</span> (listen)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Moment</span> a <span class="ot">=</span> <span class="dt">Moment</span> {<span class="ot"> runMoment ::</span> <span class="dt">WriterT</span> [<span class="dt">IO</span> ()] <span class="dt">IO</span> a }</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">deriving</span> (<span class="dt">Monad</span>, <span class="dt">Applicative</span>, <span class="dt">Functor</span>, <span class="dt">MonadWriter</span> [<span class="dt">IO</span> ()], <span class="dt">MonadIO</span>, <span class="dt">MonadFix</span>)</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="ot">hold ::</span> a <span class="ot">-&gt;</span> <span class="dt">Event</span> a <span class="ot">-&gt;</span> <span class="dt">React</span> (<span class="dt">Behavior</span> a)</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>hold initial updates <span class="ot">=</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">do</span> cell <span class="ot">&lt;-</span> newIORef initial</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>     <span class="op">...</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>     unregisterUpdates <span class="ot">&lt;-</span> _eventRegisterListener updates (\x <span class="ot">-&gt;</span> tell [writeIORef cell x])</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>     <span class="op">...</span></span></code></pre></div>
<p>We will also need a function that can run a <code>Moment a</code> inside <code>IO</code>.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="ot">sync ::</span> <span class="dt">Moment</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>sync m <span class="ot">=</span> <span class="kw">do</span> (a, updateHolds) <span class="ot">&lt;-</span> runWriterT (runMoment m)</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>            <span class="fu">sequence_</span> updateHolds</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>            <span class="fu">return</span> a</span></code></pre></div>
<p>Note that we will also have to update our use of <code>Moment</code> elsewhere, including adding <code>liftIO</code>’s as
necessary. All of these changes are made in the <a href="https://github.com/tathougies/react.hs">GitHub source</a>.</p>
<h2 id="wrapping-things-up-in-the-real-world">Wrapping things up in the real world</h2>
<p>Finally, let’s create some utility functions to listen to <code>Event</code>’s and <code>Behavior</code>’s, thus
completing our interactions with the real world. This will also allow us to keep our implementations
of <code>Event</code> and <code>Behavior</code> opaque.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ot">listen ::</span> <span class="dt">Event</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Moment</span> ()) <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">IO</span> ())</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>listen <span class="ot">=</span> _eventRegisterListener</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- The listener here is called once to observe the behavior's initial value</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- and subsequently on updates. In some ways, it breaks the abstraction of</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- a continuous-time value, but it's a concession to practicality</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="ot">listenToBehavior ::</span> <span class="dt">Behavior</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Moment</span> ()) <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">IO</span> ())</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>listenToBehavior bb handle <span class="ot">=</span> <span class="kw">do</span> sync <span class="op">$</span> <span class="kw">do</span> initial <span class="ot">&lt;-</span> sample bb</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>                                          handle initial</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>                                listen (_behaviorUpdates bb) (() <span class="ot">-&gt;</span> sample bb <span class="op">&gt;&gt;=</span> handle)</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a><span class="ot">sample ::</span> <span class="dt">Behavior</span> a <span class="ot">-&gt;</span> <span class="dt">Moment</span> a</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>sample <span class="ot">=</span> _behaviorGetValue</span></code></pre></div>
<p>Again, the functions here are pretty self-explanatory, except perhaps <code>listenToBehavior</code>. Basically,
we call the handler once with the initial sampled value of <code>bb</code> and then we register to updates from
<code>bb</code> and call the handler using the value of <code>bb.</code></p>
<p>This all looks good, but there’s a problem with sampling <code>bb</code> in the <code>_behaviorUpdates bb</code>
handler. Remember how we took care to make sure that <code>Behavior</code>’s do not update until the current
<code>Moment</code> is complete? This means that when we sample <code>bb</code> here we will be getting the <em>old</em>
value. That’s not what we want! To remedy this, we’ll use the same trick we used with <code>hold</code>. We
will modify <code>Moment</code> to keep track of IO actions to run after all the holds have been updated.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Moment</span> a <span class="ot">=</span> <span class="dt">Moment</span> {<span class="ot"> runMoment ::</span> <span class="dt">WriterT</span> ([<span class="dt">IO</span> ()], [<span class="dt">IO</span> ()]) <span class="dt">IO</span> a }</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">deriving</span> (<span class="dt">Monad</span>, <span class="dt">Applicative</span>, <span class="dt">Functor</span>, <span class="dt">MonadWriter</span> ([<span class="dt">IO</span> ()], [<span class="dt">IO</span> ()]), <span class="dt">MonadIO</span>, <span class="dt">MonadFix</span>)</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="ot">listenToBehavior ::</span> <span class="dt">Behavior</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Moment</span> ()) <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">IO</span> ())</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>listenToBehavior bb handle <span class="ot">=</span> <span class="kw">do</span> sync <span class="op">$</span> <span class="kw">do</span> initial <span class="ot">&lt;-</span> sample bb</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>                                          handle initial</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>                                <span class="kw">let</span> handle' <span class="ot">=</span> sync (sample bb <span class="op">&gt;&gt;=</span> handle)</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>                                listen (_behaviorUpdates bb) (() <span class="ot">-&gt;</span> tell ([], [handle']))</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a><span class="ot">sync ::</span> <span class="dt">Moment</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>sync m <span class="ot">=</span> <span class="kw">do</span> (a, (updateHolds, afterHolds)) <span class="ot">&lt;-</span> runWriterT (runMoment m)</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>            <span class="fu">sequence_</span> updateHolds</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>            <span class="fu">sequence_</span> afterHolds</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>            <span class="fu">return</span> a</span></code></pre></div>
<p>Again, previous <code>Moment</code> usages will have to be updated to reflect this new structure, which has
been done in the <a href="https://github.com/tathougies/react.hs">GitHub source</a>.</p>
<h2 id="some-other-primitives">Some other primitives</h2>
<p>Modern FRP libraries usually contain a few other primitives, which we’ll implement here. One of the
more important features is the ability to define accumulators, <code>Event</code>’s whose value depends on
previous values. Let’s write the <code>accum</code> primitive now.</p>
<h3 id="keeping-state">Keeping state</h3>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ot">accum ::</span> a <span class="ot">-&gt;</span> <span class="dt">Event</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">React</span> (<span class="dt">Event</span> a)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>accum initial updaters <span class="ot">=</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">do</span> cell <span class="ot">&lt;-</span> newIORef</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>     (registerListener, propagateListeners) <span class="ot">&lt;-</span> newEventRegistration</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>     <span class="kw">let</span> evt <span class="ot">=</span> <span class="dt">Event</span> registerListener</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>     unregisterEventListener <span class="ot">&lt;-</span> _eventRegisterListener updaters <span class="op">$</span> \updater <span class="ot">-&gt;</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>                                <span class="kw">do</span> cellValue <span class="ot">&lt;-</span> liftIO (modifyIORef cell updater <span class="op">&gt;&gt;</span> readIORef cell)</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>                                   propagateListeners cellValue</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>     addFinalizer evt unregisterEventListener</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>     <span class="fu">return</span> evt</span></code></pre></div>
<p>For <code>accum</code> we create an <code>IORef</code> to hold the current value, and then subscribe to the <code>updaters</code>
event directly. We must subscribe to <code>updaters</code> here, which means that <code>accum</code> must be run in the
<code>React</code> monad. If we didn’t subscribe to <code>updaters</code> immediately, then it’s possible that we will
miss some updates. We also play nice by registering a finalizer on the new event we create.</p>
<p>Using <code>accum</code> and <code>hold</code> we can make a <code>Behavior a</code> whose current value depends on previous ones as
well.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ot">accumB ::</span> a <span class="ot">-&gt;</span> <span class="dt">Event</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">React</span> (<span class="dt">Behavior</span> a)</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>accumB initial updaters <span class="ot">=</span> <span class="kw">do</span> ea <span class="ot">&lt;-</span> accum initial updaters</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>                             hold initial ea</span></code></pre></div>
<h3 id="spilling-the-beans">Spilling the beans</h3>
<p><code>reactive-banana</code> and <code>sodium</code> also have a primitive that takes an event whose value is a list and
returns an event of just values that fires for each element in the list. This is called something
like <code>spill.</code></p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ot">spill ::</span> <span class="dt">Event</span> [a] <span class="ot">-&gt;</span> <span class="dt">Event</span> a</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>spill eas <span class="ot">=</span> <span class="dt">Event</span> (\listener <span class="ot">-&gt;</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>                   _eventRegisterListener eas <span class="op">$</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>                   \as <span class="ot">-&gt;</span> <span class="fu">mapM_</span> listener as)</span></code></pre></div>
<p>Simply put, when someone listens to the <code>spill</code>ed event, we subscribe to the <code>Event [a]</code> and call
the listener for <code>Event a</code> on each element of the list.</p>
<h3 id="calming-down">Calming down</h3>
<p><code>spill</code> gave us the ability to have one event produce multiple simultaneous events, but what if we
don’t want to listen to all of those? What if we wanted to “un-<code>spill</code>”? Luckily, there’s a
combinator for that, usually called <code>calm</code>. It takes an event that may fire more than once in a
given <code>Moment</code> and returns a new <code>Event</code> that will only fire once for the first firing of the
event. We will need to modify the <code>Moment</code> monad again to keep track of which events have already
been delivered.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.State</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Set</span> <span class="kw">as</span> <span class="dt">S</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Moment</span> a <span class="ot">=</span> <span class="dt">Moment</span> {<span class="ot"> runMoment ::</span> <span class="dt">StateT</span> (<span class="dt">S.Set</span> <span class="dt">Unique</span>) (<span class="dt">WriterT</span> ([<span class="dt">IO</span> ()], [<span class="dt">IO</span> ()]) <span class="dt">IO</span>) a }</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Monad</span>, <span class="dt">Applicative</span>, <span class="dt">Functor</span>, <span class="dt">MonadState</span> (<span class="dt">S.Set</span> <span class="dt">Unique</span>), <span class="dt">MonadWriter</span> ([<span class="dt">IO</span> ()], [<span class="dt">IO</span> ()]),</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>           ,<span class="dt">MonadIO</span>, <span class="dt">MonadFix</span>)</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a><span class="ot">sync ::</span> <span class="dt">Moment</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>sync m <span class="ot">=</span> <span class="kw">do</span> (a, (updateHolds, afterHolds)) <span class="ot">&lt;-</span> runWriterT (evalStateT (runMoment m) S.empty)</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>            <span class="fu">sequence_</span> updateHolds</span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>            <span class="fu">sequence_</span> afterHolds</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>            <span class="fu">return</span> a</span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a><span class="ot">calm ::</span> <span class="dt">Event</span> a <span class="ot">-&gt;</span> <span class="dt">React</span> (<span class="dt">Event</span> a)</span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>calm evt <span class="ot">=</span> <span class="kw">do</span> key <span class="ot">&lt;-</span> liftIO newUnique</span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a>              <span class="kw">let</span> evt <span class="ot">=</span> <span class="dt">Event</span> <span class="op">$</span> \listener <span class="ot">-&gt;</span> _eventRegisterListener evt (calmed listener)</span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a>                  calmed listener a <span class="ot">=</span></span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">do</span> alreadyCalled <span class="ot">&lt;-</span> S.member key <span class="op">&lt;$&gt;</span> get</span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a>                       when (<span class="fu">not</span> alreadyCalled) <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a>                         modify (S.insert key)</span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a>                         listener a</span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true" tabindex="-1"></a>              <span class="fu">return</span> evt</span></code></pre></div>
<p>Basically, <code>calm</code> adapts the listener to check if the listener has been called yet in this
moment. If it has not, then it calls the listener and notes in this <code>Moment</code> that the listener has
been called. Sweet!</p>
<h3 id="switching-things-up">Switching things up</h3>
<p>The most complicated combinator we’re going to write today is <code>switchE</code> and <code>switch</code>. These
combinators let you dynamically change the state of the network. The <code>switchE</code> combinator takes a
<code>Behavior (Event a)</code> and returns an <code>Event a</code> that fires whenever the <em>current</em> <code>Event a</code> in the
given <code>Behavior</code> fires. This requires some trickery, but we actually don’t need to write this in the
<code>React</code> monad.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="ot">switchE ::</span> <span class="dt">Behavior</span> (<span class="dt">Event</span> a) <span class="ot">-&gt;</span> <span class="dt">Event</span> a</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>switchE be <span class="ot">=</span> <span class="dt">Event</span> <span class="op">$</span> \listener <span class="ot">-&gt;</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>             <span class="kw">do</span> eInitial <span class="ot">&lt;-</span> sync <span class="op">$</span> sample be</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>                unregisterV <span class="ot">&lt;-</span> newIORef (<span class="fu">return</span> ())</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>                unregisterListener <span class="ot">&lt;-</span> _eventRegisterListener eInitial listener</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>                writeIORef unregisterV unregisterListener</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>                <span class="kw">let</span> switchToNewEvent <span class="ot">=</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>                      <span class="kw">do</span> unregisterFromOld <span class="ot">&lt;-</span> readIORef unregisterV</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>                         unregisterFromOld</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>                         eNext <span class="ot">&lt;-</span> sync <span class="op">$</span> sample be</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>                         unregisterNewListener <span class="ot">&lt;-</span> _eventRegisterListener eNext listener</span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>                         writeIORef unregisterV unregisterNewListener</span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>                unregisterBehaviorListener <span class="ot">&lt;-</span> _eventRegisterListener (_behaviorUpdates be) <span class="op">$</span> \() <span class="ot">-&gt;</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>                                              tell ([], [switchToNewEvent])</span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>                <span class="fu">return</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>                  unregisterEvtListener <span class="ot">&lt;-</span> readIORef unregisterV</span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>                  unregisterEvtListener</span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>                  unregisterBehaviorListener</span></code></pre></div>
<p>Basically, what this does is that, whenever a new listener subscribes, we subscribe to the current
<code>Event a</code> contained in the behavior, as well as the <code>Behavior</code> updates. The subscription to the
<code>Event a</code> will call our listener for events on the initial event until the <code>Behavior</code> updates. At
this point, the <code>switchToNewEvent</code> is called <em>after</em> all the new behavior values have been written
in the holds (that’s why we use <code>tell</code> to register an <code>afterHolds</code> action). Because
<code>switchToNewEvent</code> is called after the current <code>Moment</code>, the listener will continue to be called on
firings of the old event until the end of the <code>Moment</code>. This is what we want, since our convention
is that <code>Behavior</code>’s do not update until the end of the current moment.</p>
<p>When <code>switchToNewEvent</code> is called, we read the current unregistration IO action from the <code>IORef</code> and
run it, thus disconnecting <code>listener</code> from future firings of the old <code>Event a</code>. We read the new
<code>Event a</code> from the behavior and register <code>listener</code> to listen to the new event instead. Finally, we
write out the deregistration function for the new event fo the <code>IORef</code>. The deregistration function
for the dynamically switched event disconnects both the listener from the current event and
<code>switchToNewEvent</code> from the behavior updates.</p>
<p>Whereas <code>switchE</code> dynamically switches between <code>Event a</code>’s, <code>switch</code> dynamically switches between
<code>Behavior</code>’s. Remember, we need to two things to define a behavior: an event that updates when the
behavior updates, and a way to read the current value. The <code>switchE</code> gives us an easy way to express
the former, and it’s pretty straightforward to write a function to read the current value.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="ot">switch ::</span> <span class="dt">Behavior</span> (<span class="dt">Behavior</span> a) <span class="ot">-&gt;</span> <span class="dt">Behavior</span> a</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>switch bb <span class="ot">=</span> <span class="dt">Behavior</span> { _behaviorUpdates <span class="ot">=</span> switchE (_behaviorUpdates <span class="op">&lt;$&gt;</span> bb)</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>                     , _behaviorGetValue <span class="ot">=</span> <span class="kw">do</span> b <span class="ot">&lt;-</span> sample bb</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>                                              sample b }</span></code></pre></div>
<h2 id="conclusion">Conclusion</h2>
<p>And that’s it! In this post, we’ve written a simple FRP implementation in less than 200
lines. Unlike it’s more complicated cousins, like reactive-banana or sodium, this implementation
makes no performance or memory guarantees, and doesn’t even have very strict semantics, but you’ll
find it works pretty intuitively for <em>most things</em> (TM). In the next tutorial, we’ll use our library
to write a simple game. Stay tuned for more, and be sure to check out the <a href="https://github.com/tathougies/react.hs">GitHub source for
React.Hs</a>.</p>
</div>

<div id="disqus_thread"></div>
<script type="text/javascript">
/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
var disqus_shortname = 'travisathougiessblog'; // required: replace example with your forum shortname

/* * * DON'T EDIT BELOW THIS LINE * * */
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

        </div>
        <!-- Google Analytics Tracking -->
        <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-55204994-1', 'auto');
        ga('send', 'pageview');

        </script>
    </body>
</html>
