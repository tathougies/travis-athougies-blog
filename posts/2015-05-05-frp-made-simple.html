<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0" />
        <title>Travis Athougies - FRP made simple!</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
        <link rel="stylesheet" type="text/css" href="../css/jquery.modal.css" />
        <link href="http://fonts.googleapis.com/css?family=Open+Sans:400,300,800,700" rel="stylesheet" type="text/css">
        <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/javascript" src="../js/jquery.min.js"></script>
        <script type"text javascript" src="../js/jquery.modal.min.js"></script>
	<script type="text/javascript" src="../js/isotope.min.js"></script>
	<script type="text/javascript" src="../js/imagesloaded.min.js"></script>
        <script type="text/javascript" src="../js/gallery.js"></script>
    </head>
    <body>
        <div id="mini-header-bar">
          <div id="show-header">
            ☰
          </div>
          <h1 id="mini-logo">
            <a href="../"><p class="travis">Travis</p><p>Athougies</p></a>
          </h1>
        </div>
        <div id="gallery-modal" class="modal" style="display: hidden">
          <a href="#" id="gallery-prev"></a>
          <a href="#" id="gallery-next"></a>
          <img id="gallery-image" src="#" />
          <div id="gallery-caption">
            <span class="gallery-figure">Figure <span id="figure-number">0</span> &mdash;</span><span id="caption-text"></span>
          </div>
        </div>
        <div id="header">
            <h1 id="logo">
                <a href="../"><p class="travis">Travis</p><p>Athougies</p></a>
            </h1>
            <div id="taglines">
              technologist
              dreamer
              builder
            </div>
            <ul id="navigation">
              <li><h2>Navigation</h2>
                <ul>
                  <li><a href="../">Home</a></li>
                  <li><a href="../about.html">About</a></li>
                  <li><a href="../projects.html">Projects</a></li>
                  <li><a href="../contact.html">Contact</a></li>
                  <li><a href="../archive.html">Archive</a></li>
                </ul></li>
              <li><h2>Tags</h2>
                <ul>
                
                  <li><a href="../tags/haskell.html">haskell (14)</a></li>
                
                  <li><a href="../tags/hydroponics.html">hydroponics (9)</a></li>
                
                  <li><a href="../tags/sustainability.html">sustainability (5)</a></li>
                
                  <li><a href="../tags/gardening.html">gardening (4)</a></li>
                
                  <li><a href="../tags/beam.html">beam (3)</a></li>
                
                  <li><a href="../tags/web.html">web (2)</a></li>
                
                  <li><a href="../tags/math.html">math (2)</a></li>
                
                  <li><a href="../tags/hakyll.html">hakyll (1)</a></li>
                
                  <li><a href="../tags/food.html">food (1)</a></li>
                
                  <li><a href="../tags/finance.html">finance (1)</a></li>
                
                  <li><a href="../tags/databases.html">databases (1)</a></li>
                
                  <li><a href="../tags/business.html">business (1)</a></li>
                
                  <li><a href="../tags/agriculture.html">agriculture (1)</a></li>
                </ul></li>
            </ul>
          <div id="shamelessplug">
              Site proudly generated by
              <a href="http://jaspervdj.be/hakyll">Hakyll</a> <p></p>
              This site kept updated by <a href="http://travis-ci.org">Travis CI</a> <p></p>
              <img src="https://travis-ci.org/tathougies/travis-athougies-blog.svg?branch=master" />
          </div>
        </div>

        <div id="content">
            <h1>FRP made simple!</h1>

            <div class="info">
    Posted on <span class="date">May  5, 2015</span>
    
        by <span class="author">Travis Athougies</span>
    
</div>
<div class="tags">
  in
  <ul>
    
    <li><a href="../tags/haskell.html">haskell</a></li>
    
  </ul>
</div>



<div id="post">
<p>Functional Reactive Programming refers to a declarative way to write eventful program in functional languages like Haskell. While the concepts behind FRP are straightforward to grasp, the actual implementations are not.</p>
<p>Libraries like sodium, reactive-banana, elerea, and yampa share one thing in common: large code bases that are not easily understood by beginners. In this blog post, I will develop a sodium-like FRP implementation for Haskell in under 200 lines. Note that this is possible by eschewing any concerns over performance or memory usage, so this library would probably not be practical to use in any live code.</p>
<h2 id="a-brief-recap-of-frp">A brief recap of FRP</h2>
<p>FRP libraries usually consist of two primitives: <code>Event</code> and <code>Behavior</code>. An <code>Event</code> refers to values which only occur at certain times, and which are lost after the moment they occur. You can think of an <code>Event a</code> as a list of pairs of times <code>t</code> and values <code>a</code>: <code>[(t, a)]</code>. A <code>Behavior</code> is a continuous value. Here, continuous means that a <code>Behavior</code> has a defined value for any given time (not the mathematical definition!). We can think of a <code>Behavior a</code> as a function from a time <code>t</code> to the value <code>a</code>.</p>
<h2 id="first-steps">First steps</h2>
<p>The first thing we will do is define a monad for all of our FRP computations. Our FRP implementation will also allow us to execute arbitrary <code>IO</code> actions in response to events (much like the <code>execute</code> primitive in Sodium), so we will need a separate monad to represent what happens “in the moment.” Right now, we’ll just make both of these monads aliases for <code>IO</code>.</p>
<p>Also, before we start, the final library we will end up writing is available on <a href="https://github.com/tathougies/react.hs">GitHub.</a></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">type</span> <span class="dt">React</span> <span class="fu">=</span> <span class="dt">IO</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="kw">type</span> <span class="dt">Moment</span> <span class="fu">=</span> <span class="dt">IO</span></a></code></pre></div>
<p>In many FRP implementations, <code>Behavior</code> actually isn’t anything more than a step function whose value can only be updated by events. Therefore, we’ll start by defining our <code>Event</code> type. The only really important thing about events is that we be able to subscribe and unsubscibe from them.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">type</span> <span class="dt">RegisterEventListener</span> a <span class="fu">=</span> (a <span class="ot">-&gt;</span> <span class="dt">Moment</span> ()) <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">IO</span> ())</a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="kw">newtype</span> <span class="dt">Event</span> a <span class="fu">=</span> <span class="dt">Event</span> {<span class="ot"> _eventRegisterListener ::</span> <span class="dt">RegisterEventListener</span> a }</a></code></pre></div>
<p>First, we define the <code>RegisterEventListener</code> type. Functions of this type can be used to register a function in the <code>Moment</code> monad which will be called whenever a new value (of type <code>a</code>) of the event is produced. The listener must be registered in the <code>IO</code> monad, and the registration function returns another monadic action of type <code>IO ()</code>. This function is used to deregister the listener that has been added.</p>
<p><code>Event a</code> fills the requirements for both a <code>Monoid</code> and a <code>Functor</code>. For the <code>Monoid</code> instance, <code>mempty</code> is the Event that never fires, and <code>mappend</code> takes two <code>Event a</code>’s and returns a new <code>Event a</code> that fires whenever either of the first two fires.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Monoid</span> (<span class="dt">Event</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">  mempty <span class="fu">=</span> never</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">  mappend <span class="fu">=</span> merge</a>
<a class="sourceLine" id="cb3-4" data-line-number="4"></a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="ot">never ::</span> <span class="dt">Event</span> a</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">never <span class="fu">=</span> <span class="dt">Event</span> (\_ <span class="ot">-&gt;</span> return (return ()))</a>
<a class="sourceLine" id="cb3-7" data-line-number="7"></a>
<a class="sourceLine" id="cb3-8" data-line-number="8"><span class="ot">merge ::</span> <span class="dt">Event</span> a <span class="ot">-&gt;</span> <span class="dt">Event</span> a <span class="ot">-&gt;</span> <span class="dt">Event</span> a</a>
<a class="sourceLine" id="cb3-9" data-line-number="9">merge a b <span class="fu">=</span> <span class="dt">Event</span> (\listener <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb3-10" data-line-number="10">                     unregisterA <span class="ot">&lt;-</span> _eventRegisterListener a listener</a>
<a class="sourceLine" id="cb3-11" data-line-number="11">                     unregisterB <span class="ot">&lt;-</span> _eventRegisterListener b listener</a>
<a class="sourceLine" id="cb3-12" data-line-number="12">                     return (unregisterA <span class="fu">&gt;&gt;</span> unregisterB))</a></code></pre></div>
<p>Let’s look at each function individually. First, let’s consider the <code>mempty</code> or <code>never</code> functions. Whenever a listener tries to register with this event, the listener is totally ignored and the deregistration function returned does nothing. This means that the listener will never be called (i.e., the event will never fire), which is the behavior we wanted.</p>
<p>The <code>mappend</code> or <code>merge</code> function take two events and returns a new one. When a listener tries to register with the new event, the listener is in fact registered with both events. Thus, the listener will be called whenever either <code>a</code> or <code>b</code> fire, which is the behavior we wanted. The deregistration function deregisters the listener from both <code>a</code> and <code>b</code>.</p>
<p>Now for the <code>Functor</code> instance. The <code>Functor</code> instance for event allows us to apply functions to the value contained inside an event in order to a get a new dependent event. I’ve included a type signature to remind the reader of the type of the <code>fmap</code> function for <code>Event</code>’s.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Event</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="ot">  fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Event</span> a <span class="ot">-&gt;</span> <span class="dt">Event</span> b</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  fmap f eb <span class="fu">=</span> <span class="dt">Event</span> (\listener <span class="ot">-&gt;</span> _eventRegisterListener eb (listener <span class="fu">.</span> f))</a></code></pre></div>
<p>In <code>fmap</code>, we translate our listening function to be able to listen to the original event, and then subscribe it to that. Recall that <code>eb</code> has type <code>Event b</code>, so <code>_eventRegisterListener eb</code> has type <code>(b -&gt; Moment ()) -&gt; IO (IO ())</code>. The <code>listener</code> function we’ve been supplied has type <code>a -&gt; Moment ()</code>, but <code>listener . f</code> has type <code>b -&gt; Moment()</code>, so we can use it as the new listener for <code>eb</code>.</p>
<h2 id="getting-behaviors-to-behave">Getting behaviors to behave</h2>
<p>As we said before, although we can think of <code>Behavior</code>s as continuous-time properties, in reality, our FRP implementation will treat them as stepper functions that must be updated by an event. Therefore, every <code>Behavior</code> will need to be tied with an event that will fire whenever the behavior is updated. Secondly, although the value of <code>Behavior</code> is impure (it changes through time), its value is well defined given a point in time. Therefore, we should be able to access it through <code>Moment</code>. Thus, our <code>Behavior</code> type will also have to support a way to get at its current value.</p>
<p>It’s easy to combine these requirements into a <code>Behavior</code> data type, which consists of an event which fires on updates and a function to get the current value.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Behavior</span> a <span class="fu">=</span> <span class="dt">Behavior</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">                {<span class="ot"> _behaviorUpdates ::</span> <span class="dt">Event</span> ()</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">                ,<span class="ot"> _behaviorGetValue ::</span> <span class="dt">Moment</span> a }</a></code></pre></div>
<p>It turns out that <code>Behavior</code> is an <code>Applicative</code>. The <code>pure</code> function for <code>Behavior</code> will return a <code>Behavior</code> whose value does not change in time. The <code>(&lt;*&gt;)</code> function will return a <code>Behavior</code> whose value at any given point in time is the current value of the first <code>Behavior</code> applied to the current value of the second. I’ve included type signatures for convenience.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">import</span> <span class="dt">Control.Applicative</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"></a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Behavior</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4"><span class="ot">  pure ::</span> a <span class="ot">-&gt;</span> <span class="dt">Behavior</span> a</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">  pure a <span class="fu">=</span> <span class="dt">Behavior</span> { _behaviorUpdates <span class="fu">=</span> mempty</a>
<a class="sourceLine" id="cb6-6" data-line-number="6">                    , _behaviorGetValue <span class="fu">=</span> return a}</a>
<a class="sourceLine" id="cb6-7" data-line-number="7"><span class="ot">  (&lt;*&gt;) ::</span> <span class="dt">Behavior</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Behavior</span> a <span class="ot">-&gt;</span> <span class="dt">Behavior</span> b</a>
<a class="sourceLine" id="cb6-8" data-line-number="8">  bab <span class="fu">&lt;*&gt;</span> ba <span class="fu">=</span> <span class="dt">Behavior</span> { _behaviorUpdates <span class="fu">=</span> _behaviorUpdates bab <span class="fu">&lt;&gt;</span> _behaviorUpdates ba</a>
<a class="sourceLine" id="cb6-9" data-line-number="9">                        , _behaviorGetValue <span class="fu">=</span> <span class="kw">do</span> ab <span class="ot">&lt;-</span> _behaviorGetValue bab</a>
<a class="sourceLine" id="cb6-10" data-line-number="10">                                                 a <span class="ot">&lt;-</span> _behaviorGetValue ba</a>
<a class="sourceLine" id="cb6-11" data-line-number="11">                                                 return (ab a) }</a></code></pre></div>
<p>The <code>Behavior</code> returned by <code>pure a</code> is a <code>Behavior</code> that never updates (i.e., is constant) and whose value always returns <code>a</code>. This fulfills our requirements for a constant <code>Behavior</code>.</p>
<p>The <code>Behavior</code> returned by <code>f &lt;*&gt; a</code> is a <code>Behavior</code> who updates whenever <code>f</code> or <code>a</code> update, and whose value is the value of <code>f</code> applied to the value of <code>a</code>.</p>
<h2 id="interfacing-with-the-real-world">Interfacing with the real world</h2>
<p>So now we have <code>Event</code> and <code>Behavior</code> data type and methods to combine them with other <code>Event</code>’s and <code>Behavior</code>’s respectively. What we don’t have is any way to make an <code>Event</code> that actually fires, or a <code>Behavior</code> that is not built from other <code>Behavior</code>’s. Let’s implement this functionality to make our library actually useful.</p>
<h3 id="putting-the-r-in-frp">Putting the ‘R’ in FRP</h3>
<p>Most FRP implementations offer the user a way to create an event as well as an IO (or equivalent) function that can be used to trigger that event. Our library is no different. Let’s define a <code>newEvent</code> function which will return a new <code>Event</code> as well as a function to trigger our <code>Event</code>.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">import</span> <span class="dt">Control.Monad.Trans</span> <span class="co">-- for `liftIO`</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"></a>
<a class="sourceLine" id="cb7-3" data-line-number="3"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">M</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4"><span class="kw">import</span> <span class="dt">Data.Unique</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5"><span class="kw">import</span> <span class="dt">Data.IORef</span></a>
<a class="sourceLine" id="cb7-6" data-line-number="6"></a>
<a class="sourceLine" id="cb7-7" data-line-number="7"><span class="ot">newEvent ::</span> <span class="dt">React</span> (<span class="dt">Event</span> a, a <span class="ot">-&gt;</span> <span class="dt">Moment</span> ())</a>
<a class="sourceLine" id="cb7-8" data-line-number="8">newEvent <span class="fu">=</span> <span class="kw">do</span> (registerListener, propagateListeners) <span class="ot">&lt;-</span> newEventRegistration</a>
<a class="sourceLine" id="cb7-9" data-line-number="9">              return (<span class="dt">Event</span> registerListener, propagateListeners)</a>
<a class="sourceLine" id="cb7-10" data-line-number="10"></a>
<a class="sourceLine" id="cb7-11" data-line-number="11"><span class="ot">newEventRegistration ::</span> <span class="dt">React</span> (<span class="dt">RegisterEventListener</span> a, a <span class="ot">-&gt;</span> <span class="dt">Moment</span> ())</a>
<a class="sourceLine" id="cb7-12" data-line-number="12">newEventRegistration <span class="fu">=</span> <span class="kw">do</span> listeners <span class="ot">&lt;-</span> newIORef M.empty</a>
<a class="sourceLine" id="cb7-13" data-line-number="13">                          <span class="kw">let</span> registerListener listener <span class="fu">=</span></a>
<a class="sourceLine" id="cb7-14" data-line-number="14">                                <span class="kw">do</span> listenerKey <span class="ot">&lt;-</span> newUnique</a>
<a class="sourceLine" id="cb7-15" data-line-number="15">                                   modifyIORef listeners (M.insert listenerKey listener)</a>
<a class="sourceLine" id="cb7-16" data-line-number="16">                                   return (modifyIORef listeners (M.delete listenerKey)</a>
<a class="sourceLine" id="cb7-17" data-line-number="17">                              propagateListeners x <span class="fu">=</span></a>
<a class="sourceLine" id="cb7-18" data-line-number="18">                                <span class="kw">do</span> listeners' <span class="ot">&lt;-</span> M.elems <span class="fu">&lt;$&gt;</span> liftIO (readIORef listeners)</a>
<a class="sourceLine" id="cb7-19" data-line-number="19">                                   mapM_ (<span class="fu">$</span> x) listeners'</a>
<a class="sourceLine" id="cb7-20" data-line-number="20">                          return (registerListener, propagateListeners)</a></code></pre></div>
<p>I won’t go into all the details here, but basically, the sausage is made in the <code>newEventRegistration</code> function which uses an <code>IORef</code> to keep track of registered listeners and a <code>Unique</code> from the <code>Data.Unique</code> library to give each listener a unique key, which is useful for the deregistration function.</p>
<h3 id="hold-your-horses">Hold your horses!</h3>
<p>So now we can make an <code>Event</code> that we can fire by simply calling a function, but how do we make a <code>Behavior</code>? Simple! Since <code>Behavior</code>’s are just steppers updated by events, we’ll write a function that will take an <code>Event a</code> and give us a <code>Behavior a</code>. However, because the <code>Event a</code> might not fire immediately, we’ll need to give the <code>Behavior a</code> an initial <code>a</code> to hold in the mean-time.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">import</span> <span class="dt">System.Mem.Weak</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"></a>
<a class="sourceLine" id="cb8-3" data-line-number="3"><span class="ot">hold ::</span> a <span class="ot">-&gt;</span> <span class="dt">Event</span> a <span class="ot">-&gt;</span> <span class="dt">React</span> (<span class="dt">Behavior</span> a)</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">hold initial updates <span class="fu">=</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5">  <span class="kw">do</span> cell <span class="ot">&lt;-</span> newIORef initial</a>
<a class="sourceLine" id="cb8-6" data-line-number="6">     <span class="kw">let</span> behavior <span class="fu">=</span> <span class="dt">Behavior</span> { _behaviorUpdates <span class="fu">=</span> () <span class="fu">&lt;$</span> updates</a>
<a class="sourceLine" id="cb8-7" data-line-number="7">                             , _behaviorGetValue <span class="fu">=</span> liftIO (readIORef cell) }</a>
<a class="sourceLine" id="cb8-8" data-line-number="8">     unregisterUpdates <span class="ot">&lt;-</span> _eventRegisterListener updates (\x <span class="ot">-&gt;</span> writeIORef cell x)</a>
<a class="sourceLine" id="cb8-9" data-line-number="9">     addFinalizer behavior unregisterUpdates</a>
<a class="sourceLine" id="cb8-10" data-line-number="10">     return behavior</a></code></pre></div>
<p>Again, I won’t go into too much detail here, but basically we create an <code>IORef</code> to store the current value of the behavior, which we read out in the sampling function. The behavior updates event is made by creating an <code>Event ()</code> from the <code>Event a</code> supplied to us (i.e., the behavior will update whenever the event does). The <code>(&lt;$)</code> function is given to us for free by virtue of <code>Event</code> being a <code>Functor</code>. Finally, we register a listener for updates to the updating event, and update the cell appropriately. We use the <code>addFinalizer</code> function from <code>System.Mem.Weak</code> to automatically unregister our listener when <code>behavior</code> is garbage collected.</p>
<p>There is one more consideration that we’re not taking into account here. Because we write to the <code>IORef</code> immediately in the listener, it is possible that sampling the behavior at different points in the <code>Moment</code> monad will give us different results. This is not what we want since a computation in the moment monad should semantically run “at the same time.” What we really want is for the cell to be written after the current moment is complete. We can do this by updating our definition of the <code>Moment</code> monad.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2"><span class="kw">import</span> <span class="dt">Control.Monad.Writer</span> <span class="kw">hiding</span> (listen)</a>
<a class="sourceLine" id="cb9-3" data-line-number="3"></a>
<a class="sourceLine" id="cb9-4" data-line-number="4"><span class="kw">newtype</span> <span class="dt">Moment</span> a <span class="fu">=</span> <span class="dt">Moment</span> {<span class="ot"> runMoment ::</span> <span class="dt">WriterT</span> [<span class="dt">IO</span> ()] <span class="dt">IO</span> a }</a>
<a class="sourceLine" id="cb9-5" data-line-number="5">    <span class="kw">deriving</span> (<span class="dt">Monad</span>, <span class="dt">Applicative</span>, <span class="dt">Functor</span>, <span class="dt">MonadWriter</span> [<span class="dt">IO</span> ()], <span class="dt">MonadIO</span>, <span class="dt">MonadFix</span>)</a>
<a class="sourceLine" id="cb9-6" data-line-number="6"></a>
<a class="sourceLine" id="cb9-7" data-line-number="7"><span class="ot">hold ::</span> a <span class="ot">-&gt;</span> <span class="dt">Event</span> a <span class="ot">-&gt;</span> <span class="dt">React</span> (<span class="dt">Behavior</span> a)</a>
<a class="sourceLine" id="cb9-8" data-line-number="8">hold initial updates <span class="fu">=</span></a>
<a class="sourceLine" id="cb9-9" data-line-number="9">  <span class="kw">do</span> cell <span class="ot">&lt;-</span> newIORef initial</a>
<a class="sourceLine" id="cb9-10" data-line-number="10">     <span class="fu">...</span></a>
<a class="sourceLine" id="cb9-11" data-line-number="11">     unregisterUpdates <span class="ot">&lt;-</span> _eventRegisterListener updates (\x <span class="ot">-&gt;</span> tell [writeIORef cell x])</a>
<a class="sourceLine" id="cb9-12" data-line-number="12">     <span class="fu">...</span></a></code></pre></div>
<p>We will also need a function that can run a <code>Moment a</code> inside <code>IO</code>.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">import</span> <span class="dt">Control.Monad</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2"></a>
<a class="sourceLine" id="cb10-3" data-line-number="3"><span class="ot">sync ::</span> <span class="dt">Moment</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">sync m <span class="fu">=</span> <span class="kw">do</span> (a, updateHolds) <span class="ot">&lt;-</span> runWriterT (runMoment m)</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">            sequence_ updateHolds</a>
<a class="sourceLine" id="cb10-6" data-line-number="6">            return a</a></code></pre></div>
<p>Note that we will also have to update our use of <code>Moment</code> elsewhere, including adding <code>liftIO</code>’s as necessary. All of these changes are made in the <a href="https://github.com/tathougies/react.hs">GitHub source</a>.</p>
<h2 id="wrapping-things-up-in-the-real-world">Wrapping things up in the real world</h2>
<p>Finally, let’s create some utility functions to listen to <code>Event</code>’s and <code>Behavior</code>’s, thus completing our interactions with the real world. This will also allow us to keep our implementations of <code>Event</code> and <code>Behavior</code> opaque.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="ot">listen ::</span> <span class="dt">Event</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Moment</span> ()) <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">IO</span> ())</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">listen <span class="fu">=</span> _eventRegisterListener</a>
<a class="sourceLine" id="cb11-3" data-line-number="3"></a>
<a class="sourceLine" id="cb11-4" data-line-number="4"><span class="co">-- The listener here is called once to observe the behavior's initial value</span></a>
<a class="sourceLine" id="cb11-5" data-line-number="5"><span class="co">-- and subsequently on updates. In some ways, it breaks the abstraction of</span></a>
<a class="sourceLine" id="cb11-6" data-line-number="6"><span class="co">-- a continuous-time value, but it's a concession to practicality</span></a>
<a class="sourceLine" id="cb11-7" data-line-number="7"><span class="ot">listenToBehavior ::</span> <span class="dt">Behavior</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Moment</span> ()) <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">IO</span> ())</a>
<a class="sourceLine" id="cb11-8" data-line-number="8">listenToBehavior bb handle <span class="fu">=</span> <span class="kw">do</span> sync <span class="fu">$</span> <span class="kw">do</span> initial <span class="ot">&lt;-</span> sample bb</a>
<a class="sourceLine" id="cb11-9" data-line-number="9">                                          handle initial</a>
<a class="sourceLine" id="cb11-10" data-line-number="10">                                listen (_behaviorUpdates bb) (() <span class="ot">-&gt;</span> sample bb <span class="fu">&gt;&gt;=</span> handle)</a>
<a class="sourceLine" id="cb11-11" data-line-number="11"></a>
<a class="sourceLine" id="cb11-12" data-line-number="12"><span class="ot">sample ::</span> <span class="dt">Behavior</span> a <span class="ot">-&gt;</span> <span class="dt">Moment</span> a</a>
<a class="sourceLine" id="cb11-13" data-line-number="13">sample <span class="fu">=</span> _behaviorGetValue</a></code></pre></div>
<p>Again, the functions here are pretty self-explanatory, except perhaps <code>listenToBehavior</code>. Basically, we call the handler once with the initial sampled value of <code>bb</code> and then we register to updates from <code>bb</code> and call the handler using the value of <code>bb.</code></p>
<p>This all looks good, but there’s a problem with sampling <code>bb</code> in the <code>_behaviorUpdates bb</code> handler. Remember how we took care to make sure that <code>Behavior</code>’s do not update until the current <code>Moment</code> is complete? This means that when we sample <code>bb</code> here we will be getting the <em>old</em> value. That’s not what we want! To remedy this, we’ll use the same trick we used with <code>hold</code>. We will modify <code>Moment</code> to keep track of IO actions to run after all the holds have been updated.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Moment</span> a <span class="fu">=</span> <span class="dt">Moment</span> {<span class="ot"> runMoment ::</span> <span class="dt">WriterT</span> ([<span class="dt">IO</span> ()], [<span class="dt">IO</span> ()]) <span class="dt">IO</span> a }</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">    <span class="kw">deriving</span> (<span class="dt">Monad</span>, <span class="dt">Applicative</span>, <span class="dt">Functor</span>, <span class="dt">MonadWriter</span> ([<span class="dt">IO</span> ()], [<span class="dt">IO</span> ()]), <span class="dt">MonadIO</span>, <span class="dt">MonadFix</span>)</a>
<a class="sourceLine" id="cb12-3" data-line-number="3"></a>
<a class="sourceLine" id="cb12-4" data-line-number="4"><span class="ot">listenToBehavior ::</span> <span class="dt">Behavior</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Moment</span> ()) <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">IO</span> ())</a>
<a class="sourceLine" id="cb12-5" data-line-number="5">listenToBehavior bb handle <span class="fu">=</span> <span class="kw">do</span> sync <span class="fu">$</span> <span class="kw">do</span> initial <span class="ot">&lt;-</span> sample bb</a>
<a class="sourceLine" id="cb12-6" data-line-number="6">                                          handle initial</a>
<a class="sourceLine" id="cb12-7" data-line-number="7">                                <span class="kw">let</span> handle' <span class="fu">=</span> sync (sample bb <span class="fu">&gt;&gt;=</span> handle)</a>
<a class="sourceLine" id="cb12-8" data-line-number="8">                                listen (_behaviorUpdates bb) (() <span class="ot">-&gt;</span> tell ([], [handle']))</a>
<a class="sourceLine" id="cb12-9" data-line-number="9"></a>
<a class="sourceLine" id="cb12-10" data-line-number="10"><span class="ot">sync ::</span> <span class="dt">Moment</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</a>
<a class="sourceLine" id="cb12-11" data-line-number="11">sync m <span class="fu">=</span> <span class="kw">do</span> (a, (updateHolds, afterHolds)) <span class="ot">&lt;-</span> runWriterT (runMoment m)</a>
<a class="sourceLine" id="cb12-12" data-line-number="12">            sequence_ updateHolds</a>
<a class="sourceLine" id="cb12-13" data-line-number="13">            sequence_ afterHolds</a>
<a class="sourceLine" id="cb12-14" data-line-number="14">            return a</a></code></pre></div>
<p>Again, previous <code>Moment</code> usages will have to be updated to reflect this new structure, which has been done in the <a href="https://github.com/tathougies/react.hs">GitHub source</a>.</p>
<h2 id="some-other-primitives">Some other primitives</h2>
<p>Modern FRP libraries usually contain a few other primitives, which we’ll implement here. One of the more important features is the ability to define accumulators, <code>Event</code>’s whose value depends on previous values. Let’s write the <code>accum</code> primitive now.</p>
<h3 id="keeping-state">Keeping state</h3>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="ot">accum ::</span> a <span class="ot">-&gt;</span> <span class="dt">Event</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">React</span> (<span class="dt">Event</span> a)</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">accum initial updaters <span class="fu">=</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3">  <span class="kw">do</span> cell <span class="ot">&lt;-</span> newIORef</a>
<a class="sourceLine" id="cb13-4" data-line-number="4">     (registerListener, propagateListeners) <span class="ot">&lt;-</span> newEventRegistration</a>
<a class="sourceLine" id="cb13-5" data-line-number="5">     <span class="kw">let</span> evt <span class="fu">=</span> <span class="dt">Event</span> registerListener</a>
<a class="sourceLine" id="cb13-6" data-line-number="6">     unregisterEventListener <span class="ot">&lt;-</span> _eventRegisterListener updaters <span class="fu">$</span> \updater <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb13-7" data-line-number="7">                                <span class="kw">do</span> cellValue <span class="ot">&lt;-</span> liftIO (modifyIORef cell updater <span class="fu">&gt;&gt;</span> readIORef cell)</a>
<a class="sourceLine" id="cb13-8" data-line-number="8">                                   propagateListeners cellValue</a>
<a class="sourceLine" id="cb13-9" data-line-number="9">     addFinalizer evt unregisterEventListener</a>
<a class="sourceLine" id="cb13-10" data-line-number="10">     return evt</a></code></pre></div>
<p>For <code>accum</code> we create an <code>IORef</code> to hold the current value, and then subscribe to the <code>updaters</code> event directly. We must subscribe to <code>updaters</code> here, which means that <code>accum</code> must be run in the <code>React</code> monad. If we didn’t subscribe to <code>updaters</code> immediately, then it’s possible that we will miss some updates. We also play nice by registering a finalizer on the new event we create.</p>
<p>Using <code>accum</code> and <code>hold</code> we can make a <code>Behavior a</code> whose current value depends on previous ones as well.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="ot">accumB ::</span> a <span class="ot">-&gt;</span> <span class="dt">Event</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">React</span> (<span class="dt">Behavior</span> a)</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">accumB initial updaters <span class="fu">=</span> <span class="kw">do</span> ea <span class="ot">&lt;-</span> accum initial updaters</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">                             hold initial ea</a></code></pre></div>
<h3 id="spilling-the-beans">Spilling the beans</h3>
<p><code>reactive-banana</code> and <code>sodium</code> also have a primitive that takes an event whose value is a list and returns an event of just values that fires for each element in the list. This is called something like <code>spill.</code></p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="ot">spill ::</span> <span class="dt">Event</span> [a] <span class="ot">-&gt;</span> <span class="dt">Event</span> a</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">spill eas <span class="fu">=</span> <span class="dt">Event</span> (\listener <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb15-3" data-line-number="3">                   _eventRegisterListener eas <span class="fu">$</span></a>
<a class="sourceLine" id="cb15-4" data-line-number="4">                   \as <span class="ot">-&gt;</span> mapM_ listener as)</a></code></pre></div>
<p>Simply put, when someone listens to the <code>spill</code>ed event, we subscribe to the <code>Event [a]</code> and call the listener for <code>Event a</code> on each element of the list.</p>
<h3 id="calming-down">Calming down</h3>
<p><code>spill</code> gave us the ability to have one event produce multiple simultaneous events, but what if we don’t want to listen to all of those? What if we wanted to “un-<code>spill</code>”? Luckily, there’s a combinator for that, usually called <code>calm</code>. It takes an event that may fire more than once in a given <code>Moment</code> and returns a new <code>Event</code> that will only fire once for the first firing of the event. We will need to modify the <code>Moment</code> monad again to keep track of which events have already been delivered.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="kw">import</span> <span class="dt">Control.Monad.State</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2"></a>
<a class="sourceLine" id="cb16-3" data-line-number="3"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Set</span> <span class="kw">as</span> <span class="dt">S</span></a>
<a class="sourceLine" id="cb16-4" data-line-number="4"></a>
<a class="sourceLine" id="cb16-5" data-line-number="5"><span class="kw">newtype</span> <span class="dt">Moment</span> a <span class="fu">=</span> <span class="dt">Moment</span> {<span class="ot"> runMoment ::</span> <span class="dt">StateT</span> (<span class="dt">S.Set</span> <span class="dt">Unique</span>) (<span class="dt">WriterT</span> ([<span class="dt">IO</span> ()], [<span class="dt">IO</span> ()]) <span class="dt">IO</span>) a }</a>
<a class="sourceLine" id="cb16-6" data-line-number="6">  <span class="kw">deriving</span> (<span class="dt">Monad</span>, <span class="dt">Applicative</span>, <span class="dt">Functor</span>, <span class="dt">MonadState</span> (<span class="dt">S.Set</span> <span class="dt">Unique</span>), <span class="dt">MonadWriter</span> ([<span class="dt">IO</span> ()], [<span class="dt">IO</span> ()]),</a>
<a class="sourceLine" id="cb16-7" data-line-number="7">           ,<span class="dt">MonadIO</span>, <span class="dt">MonadFix</span>)</a>
<a class="sourceLine" id="cb16-8" data-line-number="8"></a>
<a class="sourceLine" id="cb16-9" data-line-number="9"><span class="ot">sync ::</span> <span class="dt">Moment</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</a>
<a class="sourceLine" id="cb16-10" data-line-number="10">sync m <span class="fu">=</span> <span class="kw">do</span> (a, (updateHolds, afterHolds)) <span class="ot">&lt;-</span> runWriterT (evalStateT (runMoment m) S.empty)</a>
<a class="sourceLine" id="cb16-11" data-line-number="11">            sequence_ updateHolds</a>
<a class="sourceLine" id="cb16-12" data-line-number="12">            sequence_ afterHolds</a>
<a class="sourceLine" id="cb16-13" data-line-number="13">            return a</a>
<a class="sourceLine" id="cb16-14" data-line-number="14"></a>
<a class="sourceLine" id="cb16-15" data-line-number="15"><span class="ot">calm ::</span> <span class="dt">Event</span> a <span class="ot">-&gt;</span> <span class="dt">React</span> (<span class="dt">Event</span> a)</a>
<a class="sourceLine" id="cb16-16" data-line-number="16">calm evt <span class="fu">=</span> <span class="kw">do</span> key <span class="ot">&lt;-</span> liftIO newUnique</a>
<a class="sourceLine" id="cb16-17" data-line-number="17">              <span class="kw">let</span> evt <span class="fu">=</span> <span class="dt">Event</span> <span class="fu">$</span> \listener <span class="ot">-&gt;</span> _eventRegisterListener evt (calmed listener)</a>
<a class="sourceLine" id="cb16-18" data-line-number="18">                  calmed listener a <span class="fu">=</span></a>
<a class="sourceLine" id="cb16-19" data-line-number="19">                    <span class="kw">do</span> alreadyCalled <span class="ot">&lt;-</span> S.member key <span class="fu">&lt;$&gt;</span> get</a>
<a class="sourceLine" id="cb16-20" data-line-number="20">                       when (not alreadyCalled) <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb16-21" data-line-number="21">                         modify (S.insert key)</a>
<a class="sourceLine" id="cb16-22" data-line-number="22">                         listener a</a>
<a class="sourceLine" id="cb16-23" data-line-number="23">              return evt</a></code></pre></div>
<p>Basically, <code>calm</code> adapts the listener to check if the listener has been called yet in this moment. If it has not, then it calls the listener and notes in this <code>Moment</code> that the listener has been called. Sweet!</p>
<h3 id="switching-things-up">Switching things up</h3>
<p>The most complicated combinator we’re going to write today is <code>switchE</code> and <code>switch</code>. These combinators let you dynamically change the state of the network. The <code>switchE</code> combinator takes a <code>Behavior (Event a)</code> and returns an <code>Event a</code> that fires whenever the <em>current</em> <code>Event a</code> in the given <code>Behavior</code> fires. This requires some trickery, but we actually don’t need to write this in the <code>React</code> monad.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="ot">switchE ::</span> <span class="dt">Behavior</span> (<span class="dt">Event</span> a) <span class="ot">-&gt;</span> <span class="dt">Event</span> a</a>
<a class="sourceLine" id="cb17-2" data-line-number="2">switchE be <span class="fu">=</span> <span class="dt">Event</span> <span class="fu">$</span> \listener <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb17-3" data-line-number="3">             <span class="kw">do</span> eInitial <span class="ot">&lt;-</span> sync <span class="fu">$</span> sample be</a>
<a class="sourceLine" id="cb17-4" data-line-number="4">                unregisterV <span class="ot">&lt;-</span> newIORef (return ())</a>
<a class="sourceLine" id="cb17-5" data-line-number="5">                unregisterListener <span class="ot">&lt;-</span> _eventRegisterListener eInitial listener</a>
<a class="sourceLine" id="cb17-6" data-line-number="6">                writeIORef unregisterV unregisterListener</a>
<a class="sourceLine" id="cb17-7" data-line-number="7">                <span class="kw">let</span> switchToNewEvent <span class="fu">=</span></a>
<a class="sourceLine" id="cb17-8" data-line-number="8">                      <span class="kw">do</span> unregisterFromOld <span class="ot">&lt;-</span> readIORef unregisterV</a>
<a class="sourceLine" id="cb17-9" data-line-number="9">                         unregisterFromOld</a>
<a class="sourceLine" id="cb17-10" data-line-number="10">                         eNext <span class="ot">&lt;-</span> sync <span class="fu">$</span> sample be</a>
<a class="sourceLine" id="cb17-11" data-line-number="11">                         unregisterNewListener <span class="ot">&lt;-</span> _eventRegisterListener eNext listener</a>
<a class="sourceLine" id="cb17-12" data-line-number="12">                         writeIORef unregisterV unregisterNewListener</a>
<a class="sourceLine" id="cb17-13" data-line-number="13">                unregisterBehaviorListener <span class="ot">&lt;-</span> _eventRegisterListener (_behaviorUpdates be) <span class="fu">$</span> \() <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb17-14" data-line-number="14">                                              tell ([], [switchToNewEvent])</a>
<a class="sourceLine" id="cb17-15" data-line-number="15">                return <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb17-16" data-line-number="16">                  unregisterEvtListener <span class="ot">&lt;-</span> readIORef unregisterV</a>
<a class="sourceLine" id="cb17-17" data-line-number="17">                  unregisterEvtListener</a>
<a class="sourceLine" id="cb17-18" data-line-number="18">                  unregisterBehaviorListener</a></code></pre></div>
<p>Basically, what this does is that, whenever a new listener subscribes, we subscribe to the current <code>Event a</code> contained in the behavior, as well as the <code>Behavior</code> updates. The subscription to the <code>Event a</code> will call our listener for events on the initial event until the <code>Behavior</code> updates. At this point, the <code>switchToNewEvent</code> is called <em>after</em> all the new behavior values have been written in the holds (that’s why we use <code>tell</code> to register an <code>afterHolds</code> action). Because <code>switchToNewEvent</code> is called after the current <code>Moment</code>, the listener will continue to be called on firings of the old event until the end of the <code>Moment</code>. This is what we want, since our convention is that <code>Behavior</code>’s do not update until the end of the current moment.</p>
<p>When <code>switchToNewEvent</code> is called, we read the current unregistration IO action from the <code>IORef</code> and run it, thus disconnecting <code>listener</code> from future firings of the old <code>Event a</code>. We read the new <code>Event a</code> from the behavior and register <code>listener</code> to listen to the new event instead. Finally, we write out the deregistration function for the new event fo the <code>IORef</code>. The deregistration function for the dynamically switched event disconnects both the listener from the current event and <code>switchToNewEvent</code> from the behavior updates.</p>
<p>Whereas <code>switchE</code> dynamically switches between <code>Event a</code>’s, <code>switch</code> dynamically switches between <code>Behavior</code>’s. Remember, we need to two things to define a behavior: an event that updates when the behavior updates, and a way to read the current value. The <code>switchE</code> gives us an easy way to express the former, and it’s pretty straightforward to write a function to read the current value.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="ot">switch ::</span> <span class="dt">Behavior</span> (<span class="dt">Behavior</span> a) <span class="ot">-&gt;</span> <span class="dt">Behavior</span> a</a>
<a class="sourceLine" id="cb18-2" data-line-number="2">switch bb <span class="fu">=</span> <span class="dt">Behavior</span> { _behaviorUpdates <span class="fu">=</span> switchE (_behaviorUpdates <span class="fu">&lt;$&gt;</span> bb)</a>
<a class="sourceLine" id="cb18-3" data-line-number="3">                     , _behaviorGetValue <span class="fu">=</span> <span class="kw">do</span> b <span class="ot">&lt;-</span> sample bb</a>
<a class="sourceLine" id="cb18-4" data-line-number="4">                                              sample b }</a></code></pre></div>
<h2 id="conclusion">Conclusion</h2>
<p>And that’s it! In this post, we’ve written a simple FRP implementation in less than 200 lines. Unlike it’s more complicated cousins, like reactive-banana or sodium, this implementation makes no performance or memory guarantees, and doesn’t even have very strict semantics, but you’ll find it works pretty intuitively for <em>most things</em> (TM). In the next tutorial, we’ll use our library to write a simple game. Stay tuned for more, and be sure to check out the <a href="https://github.com/tathougies/react.hs">GitHub source for React.Hs</a>.</p>
</div>

<div id="disqus_thread"></div>
<script type="text/javascript">
/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
var disqus_shortname = 'travisathougiessblog'; // required: replace example with your forum shortname

/* * * DON'T EDIT BELOW THIS LINE * * */
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

        </div>
        <!-- Google Analytics Tracking -->
        <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-55204994-1', 'auto');
        ga('send', 'pageview');

        </script>
    </body>
</html>
