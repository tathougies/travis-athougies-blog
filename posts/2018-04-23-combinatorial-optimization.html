<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0" />
        <title>Travis Athougies - The monadic structure of combinatorial optimization</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
        <link rel="stylesheet" type="text/css" href="../css/jquery.modal.css" />
        <link href="http://fonts.googleapis.com/css?family=Open+Sans:400,300,800,700" rel="stylesheet" type="text/css">
        <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/javascript" src="../js/jquery.min.js"></script>
        <script type"text javascript" src="../js/jquery.modal.min.js"></script>
	<script type="text/javascript" src="../js/isotope.min.js"></script>
	<script type="text/javascript" src="../js/imagesloaded.min.js"></script>
        <script type="text/javascript" src="../js/gallery.js"></script>
    </head>
    <body>
        <div id="mini-header-bar">
          <div id="show-header">
            ☰
          </div>
          <h1 id="mini-logo">
            <a href="../"><p class="travis">Travis</p><p>Athougies</p></a>
          </h1>
        </div>
        <div id="gallery-modal" class="modal" style="display: hidden">
          <a href="#" id="gallery-prev"></a>
          <a href="#" id="gallery-next"></a>
          <img id="gallery-image" src="#" />
          <div id="gallery-caption">
            <span class="gallery-figure">Figure <span id="figure-number">0</span> &mdash;</span><span id="caption-text"></span>
          </div>
        </div>
        <div id="header">
            <h1 id="logo">
                <a href="../"><p class="travis">Travis</p><p>Athougies</p></a>
            </h1>
            <div id="taglines">
              technologist
              dreamer
              builder
            </div>
            <ul id="navigation">
              <li><h2>Navigation</h2>
                <ul>
                  <li><a href="../">Home</a></li>
                  <li><a href="../about.html">About</a></li>
                  <li><a href="../projects.html">Projects</a></li>
                  <li><a href="../contact.html">Contact</a></li>
                  <li><a href="../archive.html">Archive</a></li>
                </ul></li>
              <li><h2>Tags</h2>
                <ul>
                
                  <li><a href="../tags/haskell.html">haskell (16)</a></li>
                
                  <li><a href="../tags/hydroponics.html">hydroponics (9)</a></li>
                
                  <li><a href="../tags/sustainability.html">sustainability (5)</a></li>
                
                  <li><a href="../tags/gardening.html">gardening (4)</a></li>
                
                  <li><a href="../tags/math.html">math (3)</a></li>
                
                  <li><a href="../tags/beam.html">beam (3)</a></li>
                
                  <li><a href="../tags/ai.html">ai (3)</a></li>
                
                  <li><a href="../tags/web.html">web (2)</a></li>
                
                  <li><a href="../tags/type theory.html">type theory (1)</a></li>
                
                  <li><a href="../tags/physics.html">physics (1)</a></li>
                
                  <li><a href="../tags/hakyll.html">hakyll (1)</a></li>
                
                  <li><a href="../tags/food.html">food (1)</a></li>
                
                  <li><a href="../tags/finance.html">finance (1)</a></li>
                
                  <li><a href="../tags/ethics.html">ethics (1)</a></li>
                
                  <li><a href="../tags/databases.html">databases (1)</a></li>
                
                  <li><a href="../tags/business.html">business (1)</a></li>
                
                  <li><a href="../tags/agriculture.html">agriculture (1)</a></li>
                
                  <li><a href="../tags/HoTT.html">HoTT (1)</a></li>
                </ul></li>
            </ul>
          <div id="shamelessplug">
              Site proudly generated by
              <a href="http://jaspervdj.be/hakyll">Hakyll</a> <p></p>
              This site kept updated by <a href="http://travis-ci.org">Travis CI</a> <p></p>
              <img src="https://travis-ci.org/tathougies/travis-athougies-blog.svg?branch=master" />
          </div>
        </div>

        <div id="content">
            <h1>The monadic structure of combinatorial optimization</h1>

            <div class="info">
    Posted on <span class="date">April 23, 2018</span>
    
        by <span class="author">Travis Athougies</span>
    
</div>
<div class="tags">
  in
  <ul>
    
    <li><a href="../tags/haskell.html">haskell</a></li>
    
    <li><a href="../tags/math.html">math</a></li>
    
  </ul>
</div>



<div id="post">
<p>Combinatorial optimization refers to assigning discrete values to a set of
variables with the aim to minimize (or equivalently, maximize) a given objective
function.</p>
<p>In general, a combinatorial optimization problem has the form:</p>
<p>\[
\begin{aligned}
&amp; \underset{v_1,v_2, \ldots v_n}{\text{minimize}}
&amp; &amp; f(v_1, v_2, \ldots v_n) \\
&amp; \text{subject to}
&amp; &amp; v_1 \in D_1, v_2 \in D_2, \ldots v_n \in D_n
\end{aligned}
\]</p>
<p>Here, <span class="math inline">\(f\)</span> is called the objective function. The <span class="math inline">\(v_i\)</span> are the variables we’re
optimizing over and the <span class="math inline">\(D_i\)</span> are the corresponding domains. The solution to the
problem is the lowest possible value of <span class="math inline">\(f(v_i,v_2,\ldots v_n)\)</span> where all the
<span class="math inline">\(v_i\)</span> are within their corresponding domain.</p>
<p>In the mathematical notation above, our <span class="math inline">\(f\)</span> takes <span class="math inline">\(n\)</span> arguments. In Haskell,
functions only take one argument and return one value. We can achieve
higher-arity functions by writing functions that return functions.</p>
<p>We can extend this concept to our optimization problems. We’ll restrict
each optimization problem to optimize over only one variable:</p>
<p>\[
\begin{aligned}
&amp; \underset{v_1}{\text{minimize}}
&amp; &amp; f(v_1) \\
&amp; \text{subject to}
&amp; &amp; v_1 \in D_1
\end{aligned}
\]</p>
<p>To support multiple variables, we’ll just have our objective function return
another optimization problem:</p>
<p>\[
\begin{aligned}
&amp; \underset{v_1}{\text{minimize}}
&amp; \underset{v_2}{\text{minimize }}
&amp; f(v_1)(v_2) \\
&amp; &amp; \text{subject to } &amp; v_2 \in D_2 \\
&amp; \text{subject to}
&amp; v_1 \in D_1
\end{aligned}
\]</p>
<p>Notice that the inner minimization problem is simply a function over <span class="math inline">\(v_1\)</span>:</p>
<p>\[
f_{inner}(v_1) =
\begin{aligned}
&amp; \underset{v_2}{\text{minimize}}
&amp; &amp; f_{orig} (v_1)(v_2) \\
&amp; \text{subject to}
&amp; &amp; v_2 \in D_2
\end{aligned}
\]</p>
<p>Intuitively, we can optimize over numbers, because numbers have a total
ordering. We should consider whether it’s meaningful to optimize over
optimization problems as well. Otherwise, it would be meaningless to nest
problems in this way.</p>
<p>As a rough sketch, we’ll consider optimization problem <span class="math inline">\(A\)</span> to be less than <span class="math inline">\(B\)</span>
if the minimum value achievable in <span class="math inline">\(A\)</span> is less than <span class="math inline">\(B\)</span>. Intuitively, if we
evaluate a deeply nested set of problems using this ordering, we must arrive at
the minimum value achievable in the equivalent multi-variate problems. Writing
out a formal proof is left as an exercise to the reader.</p>
<h2 id="there-and-back-again">There and back again</h2>
<p>We’ve developed an intuition to convert multi-variate optimization problems to
univariate ones by nesting them. Let’s see if we can encode these problems in
Haskell.</p>
<p>First, let’s consider a particular optimization problem. Here’s a simple one to start.</p>
<p>\[
\begin{aligned}
&amp; \underset{x, y}{\text{minimize}}
&amp; &amp; x + y \\
&amp; \text{subject to}
&amp; &amp; x \in \{ 1, 2 \}, y \in \{ 3, 4 \}
\end{aligned}
\]</p>
<p>Writing this in our univariate style:</p>
<p>\[
\begin{aligned}
&amp; \underset{x}{\text{minimize}}
&amp; &amp; f_{next} (x) \\
&amp; \text{subject to}
&amp; &amp; x \in \{ 1, 2 \}
\end{aligned}
\]</p>
<p>\[
f_{next} (x) =
\begin{aligned}
&amp; \underset{y}{\text{minimize}}
&amp; &amp; x + y \\
&amp; \text{subject to}
&amp; &amp; y \in \{ 3, 4 \}
\end{aligned}
\]</p>
<p>For our Haskell representation, we’ll presume the existence of a type
(<code>Combinatorial</code>) that represents an optimization problem that minimizes a value
in a particular domain. We can construct a problem using a new combinator,
called <code>choose</code>, that takes in the domain and the objective function.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">choose ::</span> [a] <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Combinatorial</span> b</span></code></pre></div>
<p>In order to actually run our optimization, let’s suppose we have a function</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">optimize ::</span> <span class="dt">Combinatorial</span> b <span class="ot">-&gt;</span> b</span></code></pre></div>
<p>Now we can encode the problem above:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">fNext ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Combinatorial</span> <span class="dt">Double</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>fNext x <span class="ot">=</span> choose [<span class="dv">3</span>,<span class="dv">4</span>] (\y <span class="ot">-&gt;</span> x <span class="op">+</span> y)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="ot">optProblem ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Combinatorial</span> (<span class="dt">Combinatorial</span> <span class="dt">Double</span>)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>optProblem <span class="ot">=</span> choose [<span class="dv">1</span>,<span class="dv">2</span>] fNext</span></code></pre></div>
<p>Note that, if we specialize <code>optimize</code> to the return type of <code>optProblem</code>, we get</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">optimize ::</span> <span class="dt">Combinatorial</span> (<span class="dt">Combinatorial</span> b) <span class="ot">-&gt;</span> <span class="dt">Combinatorial</span> b</span></code></pre></div>
<p>Astute readers will notice that this function has the same type as an old
friend: <code>join</code>.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">join ::</span> <span class="dt">Monad</span> f <span class="ot">=&gt;</span> f (f a) <span class="ot">-&gt;</span> f a</span></code></pre></div>
<p>Recall that a type forms a monad, if it forms functor and has sensible
implementations of <code>join</code> and <code>pure</code>. Above, we saw that <code>join</code> is like
<code>optimize</code>. We can think of <code>pure</code> as the trivial optimization problem where <span class="math inline">\(f\)</span>
is the identity function and the domain contains only one value.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="fu">pure</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Combinatorial</span> a</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="fu">pure</span> x <span class="ot">=</span> choose [x] <span class="fu">id</span></span></code></pre></div>
<p>Finally, a functor needs to have a function <code>fmap</code>.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span><span class="ot"> ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</span></code></pre></div>
<p>For <code>Combinatorial</code>, this is just the function that composes the objective
function. In other words, it turns</p>
<p>\[
\begin{aligned}
&amp; \underset{v_1}{\text{minimize}}
&amp; &amp; g(v_1) \\
&amp; \text{subject to}
&amp; &amp; v_1 \in D_1
\end{aligned}
\]</p>
<p>into</p>
<p>\[
\begin{aligned}
&amp; \underset{v_1}{\text{minimize}}
&amp; &amp; f(g(v_1)) \\
&amp; \text{subject to}
&amp; &amp; v_1 \in D_1
\end{aligned}
\]</p>
<p>With that in place, we can actually get rid of the second argument in
<code>choose</code>. Let’s define a new combinator, called <code>domain</code>.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">domain ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Combinatorial</span> a</span></code></pre></div>
<p>Now we can write <code>choose</code> in terms of <code>domain</code> and <code>fmap</code>.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">choose ::</span> [a] <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Combinatorial</span> a</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>choose d f <span class="ot">=</span> <span class="fu">fmap</span> f (domain d)</span></code></pre></div>
<p>So, in other words, <code>Combinatorial</code> needs to have only three fundamental operations.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ot">domain ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Combinatorial</span> a</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Combinatorial</span> a <span class="ot">-&gt;</span> <span class="dt">Combinatorial</span> b</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="ot">join ::</span> <span class="dt">Combinatorial</span> (<span class="dt">Combinatorial</span> a) <span class="ot">-&gt;</span> <span class="dt">Combinatorial</span> a</span></code></pre></div>
<h2 id="lets-get-real">Let’s get real</h2>
<p>Enough theory. Let’s actually do this.</p>
<p>This file is <a href="https://github.com/tathougies/travis-athougies-blog/blob/master/site-content/posts/2018-04-23-combinatorial-optimization.lhs">Literate
Haskell</a>,
so we’ll need some imports and two extensions.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DeriveFunctor #-}</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE FlexibleContexts #-}</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad</span> (ap)</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.Trans</span> (lift)</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.Writer</span> (<span class="dt">WriterT</span>, runWriterT, tell)</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Ord</span> (comparing)</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Function</span> (on)</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.Random</span></span></code></pre></div>
<p>We need to find some concrete Haskell type for which we can implement <code>domain</code>
and <code>fmap</code>. An obvious choice for this is list. Here,</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ot">domain ::</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>domain <span class="ot">=</span> <span class="fu">id</span></span></code></pre></div>
<p>and <code>fmap</code> is from the standard <code>Functor</code> instance for list and <code>join</code> is from
the standard <code>Monad</code> instance.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> <span class="ot">=</span> <span class="fu">map</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="ot">join ::</span> [ [a] ] <span class="ot">-&gt;</span> [a]</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>join <span class="ot">=</span> <span class="fu">concat</span></span></code></pre></div>
<p>Going back to our original problem, we can express it using lists:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ot">simpleOpt ::</span> [<span class="dt">Double</span>]</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>simpleOpt <span class="ot">=</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">do</span> x <span class="ot">&lt;-</span> [<span class="dv">1</span>, <span class="dv">2</span>]</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    y <span class="ot">&lt;-</span> [<span class="dv">3</span>, <span class="dv">4</span>]</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">pure</span> (x <span class="op">+</span> y)</span></code></pre></div>
<p>Now, we can find the minimum using the <code>minimum</code> function. This is equivalent to
<code>optimize</code> but requires its argument to have an <code>Ord</code> instance.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="fu">minimum</span><span class="ot"> ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> a</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="ot">optimize ::</span> <span class="dt">Combinatorial</span> a <span class="ot">-&gt;</span> a</span></code></pre></div>
<p>Running <code>minimum</code> on our example:</p>
<pre class="console"><code>Main*&gt; minimum simpleOpt
4.0</code></pre>
<p>The list monad causes us to consider every solution. If we print out the value
of <code>simpleOpt</code>, we’ll see that it is a list containing every possible outcome of
our objective function</p>
<pre class="console"><code>*Main&gt; simpleOpt
[4.0,5.0,5.0,6.0]</code></pre>
<p>Evaluating every solution is the most straightforward way to solve these
problems, but it quickly becomes intractable as the problems get larger.</p>
<p>For example, the <a href="http://katrinaeg.com/simulated-annealing.html">traveling salesman
problem</a> asks us to find the
length of the shortest route through a given set of cities, visiting each city
only once, and returning to the original city. Here, our next choice of city
depends on which cities we’ve already visited.</p>
<p>We can use the list monad to formulate every possible solution to an arbitrary
traveling salesman problem.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">City</span> <span class="ot">=</span> <span class="dt">Int</span> <span class="co">-- use Int to represent a city, for now</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="ot">tsp ::</span> [ <span class="dt">City</span> ] <span class="ot">-&gt;</span> (<span class="dt">City</span> <span class="ot">-&gt;</span> <span class="dt">City</span> <span class="ot">-&gt;</span> <span class="dt">Double</span>)</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> [ <span class="dt">Double</span> ]</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>tsp [] _ <span class="ot">=</span> <span class="fu">pure</span> <span class="dv">0</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>tsp (firstCity<span class="op">:</span>cities) distance <span class="ot">=</span> go <span class="dv">0</span> firstCity cities</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>    go curDistance lastCity [] <span class="ot">=</span> <span class="fu">pure</span> (distance firstCity lastCity <span class="op">+</span> curDistance)</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>    go curDistance lastCity unvisited <span class="ot">=</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>      <span class="kw">do</span> nextCity <span class="ot">&lt;-</span> unvisited</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>         <span class="kw">let</span> unvisited' <span class="ot">=</span> <span class="fu">filter</span> (<span class="op">/=</span>nextCity) unvisited</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>         go (curDistance <span class="op">+</span> distance nextCity lastCity) nextCity unvisited'</span></code></pre></div>
<h2 id="solving-the-traveling-salesman-problem">Solving the Traveling Salesman Problem</h2>
<p>Let’s define an instance of the traveling salesman problem, with 15 cities. We’ll represent
distances between the cities using a 15x15 distance matrix, encoded as nested
lists (this example is meant to illustrate, not perform!).</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="ot">distMatrix ::</span> [ [ <span class="dt">Double</span> ] ]</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>distMatrix <span class="ot">=</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>  [ [  <span class="dv">0</span>, <span class="dv">29</span>, <span class="dv">82</span>, <span class="dv">46</span>, <span class="dv">68</span>, <span class="dv">52</span>, <span class="dv">72</span>, <span class="dv">42</span>, <span class="dv">51</span>, <span class="dv">55</span>, <span class="dv">29</span>, <span class="dv">74</span>, <span class="dv">23</span>, <span class="dv">72</span>, <span class="dv">46</span> ]</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>  , [ <span class="dv">29</span>,  <span class="dv">0</span>, <span class="dv">55</span>, <span class="dv">46</span>, <span class="dv">42</span>, <span class="dv">43</span>, <span class="dv">43</span>, <span class="dv">23</span>, <span class="dv">23</span>, <span class="dv">31</span>, <span class="dv">41</span>, <span class="dv">51</span>, <span class="dv">11</span>, <span class="dv">52</span>, <span class="dv">21</span> ]</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>  , [ <span class="dv">82</span>, <span class="dv">55</span>,  <span class="dv">0</span>, <span class="dv">68</span>, <span class="dv">46</span>, <span class="dv">55</span>, <span class="dv">23</span>, <span class="dv">43</span>, <span class="dv">41</span>, <span class="dv">29</span>, <span class="dv">79</span>, <span class="dv">21</span>, <span class="dv">64</span>, <span class="dv">31</span>, <span class="dv">51</span> ]</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>  , [ <span class="dv">46</span>, <span class="dv">46</span>, <span class="dv">68</span>,  <span class="dv">0</span>, <span class="dv">82</span>, <span class="dv">15</span>, <span class="dv">72</span>, <span class="dv">31</span>, <span class="dv">62</span>, <span class="dv">42</span>, <span class="dv">21</span>, <span class="dv">51</span>, <span class="dv">51</span>, <span class="dv">43</span>, <span class="dv">64</span> ]</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>  , [ <span class="dv">68</span>, <span class="dv">42</span>, <span class="dv">46</span>, <span class="dv">82</span>,  <span class="dv">0</span>, <span class="dv">74</span>, <span class="dv">23</span>, <span class="dv">52</span>, <span class="dv">21</span>, <span class="dv">46</span>, <span class="dv">82</span>, <span class="dv">58</span>, <span class="dv">46</span>, <span class="dv">65</span>, <span class="dv">23</span> ]</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>  , [ <span class="dv">52</span>, <span class="dv">43</span>, <span class="dv">55</span>, <span class="dv">15</span>, <span class="dv">74</span>,  <span class="dv">0</span>, <span class="dv">61</span>, <span class="dv">23</span>, <span class="dv">55</span>, <span class="dv">31</span>, <span class="dv">33</span>, <span class="dv">37</span>, <span class="dv">51</span>, <span class="dv">29</span>, <span class="dv">59</span> ]</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>  , [ <span class="dv">72</span>, <span class="dv">43</span>, <span class="dv">23</span>, <span class="dv">72</span>, <span class="dv">23</span>, <span class="dv">61</span>,  <span class="dv">0</span>, <span class="dv">42</span>, <span class="dv">23</span>, <span class="dv">31</span>, <span class="dv">77</span>, <span class="dv">37</span>, <span class="dv">51</span>, <span class="dv">46</span>, <span class="dv">33</span> ]</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>  , [ <span class="dv">42</span>, <span class="dv">23</span>, <span class="dv">43</span>, <span class="dv">31</span>, <span class="dv">52</span>, <span class="dv">23</span>, <span class="dv">42</span>,  <span class="dv">0</span>, <span class="dv">33</span>, <span class="dv">15</span>, <span class="dv">37</span>, <span class="dv">33</span>, <span class="dv">33</span>, <span class="dv">31</span>, <span class="dv">37</span> ]</span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>  , [ <span class="dv">51</span>, <span class="dv">23</span>, <span class="dv">41</span>, <span class="dv">62</span>, <span class="dv">21</span>, <span class="dv">55</span>, <span class="dv">23</span>, <span class="dv">33</span>,  <span class="dv">0</span>, <span class="dv">29</span>, <span class="dv">62</span>, <span class="dv">46</span>, <span class="dv">29</span>, <span class="dv">51</span>, <span class="dv">11</span> ]</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>  , [ <span class="dv">55</span>, <span class="dv">31</span>, <span class="dv">29</span>, <span class="dv">42</span>, <span class="dv">46</span>, <span class="dv">31</span>, <span class="dv">31</span>, <span class="dv">15</span>, <span class="dv">29</span>,  <span class="dv">0</span>, <span class="dv">51</span>, <span class="dv">21</span>, <span class="dv">41</span>, <span class="dv">23</span>, <span class="dv">37</span> ]</span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>  , [ <span class="dv">29</span>, <span class="dv">41</span>, <span class="dv">79</span>, <span class="dv">21</span>, <span class="dv">82</span>, <span class="dv">33</span>, <span class="dv">77</span>, <span class="dv">37</span>, <span class="dv">62</span>, <span class="dv">51</span>,  <span class="dv">0</span>, <span class="dv">65</span>, <span class="dv">42</span>, <span class="dv">59</span>, <span class="dv">61</span> ]</span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>  , [ <span class="dv">74</span>, <span class="dv">51</span>, <span class="dv">21</span>, <span class="dv">51</span>, <span class="dv">58</span>, <span class="dv">37</span>, <span class="dv">37</span>, <span class="dv">33</span>, <span class="dv">46</span>, <span class="dv">21</span>, <span class="dv">65</span>,  <span class="dv">0</span>, <span class="dv">61</span>, <span class="dv">11</span>, <span class="dv">55</span> ]</span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>  , [ <span class="dv">23</span>, <span class="dv">11</span>, <span class="dv">64</span>, <span class="dv">51</span>, <span class="dv">46</span>, <span class="dv">51</span>, <span class="dv">51</span>, <span class="dv">33</span>, <span class="dv">29</span>, <span class="dv">41</span>, <span class="dv">42</span>, <span class="dv">61</span>,  <span class="dv">0</span>, <span class="dv">62</span>, <span class="dv">23</span> ]</span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a>  , [ <span class="dv">72</span>, <span class="dv">52</span>, <span class="dv">31</span>, <span class="dv">43</span>, <span class="dv">65</span>, <span class="dv">29</span>, <span class="dv">46</span>, <span class="dv">31</span>, <span class="dv">51</span>, <span class="dv">23</span>, <span class="dv">59</span>, <span class="dv">11</span>, <span class="dv">62</span>,  <span class="dv">0</span>, <span class="dv">59</span> ]</span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a>  , [ <span class="dv">46</span>, <span class="dv">21</span>, <span class="dv">51</span>, <span class="dv">64</span>, <span class="dv">23</span>, <span class="dv">59</span>, <span class="dv">33</span>, <span class="dv">37</span>, <span class="dv">11</span>, <span class="dv">37</span>, <span class="dv">61</span>, <span class="dv">55</span>, <span class="dv">23</span>, <span class="dv">59</span>,  <span class="dv">0</span> ]</span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a>  ]</span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true" tabindex="-1"></a><span class="ot">distFunc ::</span> <span class="dt">City</span> <span class="ot">-&gt;</span> <span class="dt">City</span> <span class="ot">-&gt;</span> <span class="dt">Double</span></span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true" tabindex="-1"></a>distFunc a b <span class="ot">=</span> (distMatrix <span class="op">!!</span> a) <span class="op">!!</span> b</span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-23"><a href="#cb19-23" aria-hidden="true" tabindex="-1"></a><span class="ot">allCities ::</span> [ <span class="dt">City</span> ]</span>
<span id="cb19-24"><a href="#cb19-24" aria-hidden="true" tabindex="-1"></a>allCities <span class="ot">=</span> [ <span class="dv">0</span> <span class="op">..</span> <span class="dv">14</span> ]</span></code></pre></div>
<p>Solving <code>simpleOpt</code> was easy. Let’s see what happens if we attempt to minimize
the value of <code>tsp</code> using the parameters above.</p>
<pre class="console"><code>*Main&gt; minimum (tsp allCities distFunc)
... Wait until end of universe ...
Profit!</code></pre>
<p>As you can see, not much happens. Under the hood, Haskell is busy calculating
every single path, trying to find one that works. Sadly, there are trillions of
paths, so this search will take a very long time. By the time we have 60 cities
on our itinerary, we would have to examine more paths than there are particles
in the known universe. Clearly, we need a better strategy.</p>
<h2 id="if-you-cant-solve-a-problem-guess">If you can’t solve a problem, guess</h2>
<p>Oftentimes, when problems like these come up in practice, we don’t need the
<em>optimal</em> solution, and can move forward with any solution that’s <em>good enough</em>.</p>
<p><a href="https://en.wikipedia.org/wiki/Simulated_annealing">Simulated annealing</a> is one
such strategy to find a good enough solution. It is inspired by the
metallurgical process of <em>annealing</em>, whereby metal atoms are heated to high
temperatures and then slowly cooled to increase the overall strength of the
object.</p>
<p>The basic simulated annealing algorithm is as follows:</p>
<ol type="1">
<li>Choose an initial solution at random, and set a high temperature <span class="math inline">\(T\)</span>.</li>
<li>Repeat the following steps until the system has “cooled”:
<ol type="1">
<li><p>Select a random perturbation of the current solution</p></li>
<li><p>If the perturbation is better than the current solution, move towards it.
Otherwise, randomly decide to move to the neighbor, with a probability
proportional to <em>T</em>.</p>
<p>For the purposes of this article, we’ll accept a worse solution with probability</p>
<p>\[P(\text{choose worse}) = \exp\left(-\frac{1}{T}\left(\frac{f(neighbor) - f(current)}{f(current)}\right)\right)\]</p>
<p>where <span class="math inline">\(f\)</span> is the objective function.</p></li>
<li><p>Lower <span class="math inline">\(T\)</span> systematically.</p></li>
</ol></li>
<li>Return the best seen solution</li>
</ol>
<h2 id="laziness-for-the-win">Laziness for the win</h2>
<p>When we think of any combinatorial optimization problem, we soon realize that
any solution can be thought of as a path from the root of a tree to any leaf.</p>
<p>For example, for <code>simpleOpt</code>, we can construct a tree representing choices for
<code>x</code> and <code>y</code>.</p>
<figure>
<div class="figure"><a href="../images/dot/comb-opt/simpleopt.png"><img src="../images/dot/comb-opt/simpleopt.png" alt="The tree for &lt;code&gt;simpleOpt&lt;/code&gt;. The highlighted path represents one possible solution: &lt;code&gt;x=1&lt;/code&gt; and &lt;code&gt;y=3&lt;/code&gt;." style="max-width: auto"></a><p class="caption">The tree for <code>simpleOpt</code>. The highlighted path represents one possible solution: <code>x=1</code> and <code>y=3</code>.</p></div>
<figcaption>The tree for <code>simpleOpt</code>. The highlighted path represents one possible solution: <code>x=1</code> and <code>y=3</code>.</figcaption>
</figure>
<p>The traveling salesman tree is a lot larger, but is straightforwards to
construct.</p>
<figure>
<div class="figure"><a href="../images/dot/comb-opt/tsp.png"><img src="../images/dot/comb-opt/tsp.png" alt="The tree for &lt;code&gt;exampleTsp&lt;/code&gt;. The highlighted path represents one possible solution: &lt;code&gt;[0,1,2,..,12,13,14]&lt;/code&gt;." style="max-width: auto"></a><p class="caption">The tree for <code>exampleTsp</code>. The highlighted path represents one possible solution: <code>[0,1,2,..,12,13,14]</code>.</p></div>
<figcaption>The tree for <code>exampleTsp</code>. The highlighted path represents one possible solution: <code>[0,1,2,..,12,13,14]</code>.</figcaption>
</figure>
<p>Note that the interior values associated with any particular choice
are immaterial. All that matters is the structure of the edges. In the
diagrams above, we notated each edge with the assignment it
represents. The leaves are notated with solutions.</p>
<p>We can trivially encode such trees with a Haskell data type.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Combinatorial</span> a</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>   <span class="ot">=</span> <span class="dt">Choice</span> <span class="dt">Int</span> (<span class="dt">Combinatorial</span> a) [<span class="dt">Combinatorial</span> a]</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>   <span class="op">|</span> <span class="dt">Leaf</span> a</span></code></pre></div>
<p>Here, <code>Choice</code> represents a node with children. It contains one privileged child
(the next in our path) along with a list of children not in our path. The <code>Int</code>
argument is simply the cached degrees of freedom of the next child (more on this
later). As expected <code>Leaf</code> is simply a node with no children, that represents
the final result of a choice.</p>
<p><code>Combinatorial</code> is trivially a <code>Functor</code>, and we can just ask GHC to figure that
one out for us.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>   <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Functor</span>)</span></code></pre></div>
<p>Let’s define a function to figure out the number of degrees of freedom in a
given <code>Combinatorial</code>. This helps in choosing a random neighbor.</p>
<p>Firstly, a single value has no degrees of freedom</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="ot">degreesOfFreedom ::</span> <span class="dt">Combinatorial</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>degreesOfFreedom <span class="dt">Leaf</span> {} <span class="ot">=</span> <span class="dv">0</span></span></code></pre></div>
<p>A <code>Choice</code> has the degrees of freedom of its current child plus the
possibilities of choosing one of its other subtrees.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>degreesOfFreedom (<span class="dt">Choice</span> childSz _ remaining) <span class="ot">=</span> <span class="fu">length</span> remaining <span class="op">+</span> childSz</span></code></pre></div>
<p>We can also write a function to get the solution at the chosen path.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="ot">currentSolution ::</span> <span class="dt">Combinatorial</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>currentSolution (<span class="dt">Leaf</span> a) <span class="ot">=</span> a</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>currentSolution (<span class="dt">Choice</span> _ next _) <span class="ot">=</span> currentSolution next</span></code></pre></div>
<p>A bit of thinking, and there are natural applicative and monadic interfaces <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Combinatorial</span> <span class="kw">where</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> <span class="ot">=</span> <span class="dt">Leaf</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>  (<span class="op">&lt;*&gt;</span>) <span class="ot">=</span> ap</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Combinatorial</span> <span class="kw">where</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="ot">=</span> <span class="fu">pure</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Leaf</span> a <span class="op">&gt;&gt;=</span> b <span class="ot">=</span> b a</span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Choice</span> sz next rest <span class="op">&gt;&gt;=</span> f <span class="ot">=</span></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> next' <span class="ot">=</span> next <span class="op">&gt;&gt;=</span> f</span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>        sz'   <span class="ot">=</span> degreesOfFreedom next'</span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">in</span> <span class="dt">Choice</span> sz' next' (<span class="fu">map</span> (<span class="op">&gt;&gt;=</span> f) rest)</span></code></pre></div>
<p>We can write a function to introduce non-determinism into
<code>Combinatorial</code>. <code>choose</code> takes a non-empty list of possible values (the
<em>domain</em>) of a variable; it yields the current choice. For the sake of
simplicity, we <code>error</code> on an empty list, but a more robust solution would use
<code>Data.List.NonEmpty</code> or another solution.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="ot">choose ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Combinatorial</span> a</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>choose [] <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;Empty domain&quot;</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>choose [a] <span class="ot">=</span> <span class="dt">Leaf</span> a</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>choose (a<span class="op">:</span>as) <span class="ot">=</span> <span class="dt">Choice</span> <span class="dv">0</span> (<span class="dt">Leaf</span> a) (<span class="fu">map</span> <span class="dt">Leaf</span> as)</span></code></pre></div>
<p>Now, we can encode <code>tsp</code> in <code>Combinatorial</code>.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="ot">tspCombinatorial ::</span> [ <span class="dt">City</span> ] <span class="ot">-&gt;</span> (<span class="dt">City</span> <span class="ot">-&gt;</span> <span class="dt">City</span> <span class="ot">-&gt;</span> <span class="dt">Double</span>)</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>                 <span class="ot">-&gt;</span> <span class="dt">Combinatorial</span> <span class="dt">Double</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>tspCombinatorial [] _ <span class="ot">=</span> <span class="fu">pure</span> <span class="dv">0</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>tspCombinatorial (firstCity<span class="op">:</span>cities) distance <span class="ot">=</span> go <span class="dv">0</span> firstCity cities</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>    go curDistance lastCity [] <span class="ot">=</span> <span class="fu">pure</span> (distance firstCity lastCity <span class="op">+</span> curDistance)</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>    go curDistance lastCity unvisited <span class="ot">=</span></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>      <span class="kw">do</span> nextCity <span class="ot">&lt;-</span> choose unvisited</span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>         <span class="kw">let</span> unvisited' <span class="ot">=</span> <span class="fu">filter</span> (<span class="op">/=</span>nextCity) unvisited</span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a>         go (curDistance <span class="op">+</span> distance nextCity lastCity) nextCity unvisited'</span></code></pre></div>
<p>For the problem above, we can form the set of all possible
combinations.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="ot">exampleTsp ::</span> <span class="dt">Combinatorial</span> <span class="dt">Double</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>exampleTsp <span class="ot">=</span> tspCombinatorial allCities distFunc</span></code></pre></div>
<p>Now, you may think that if we try to inspect <code>exampleTsp</code>, we’ll be in for a
world of hurt. However, we can freely ask GHC for the value of <code>tsp</code> at the
chosen path, without evaluating any other possible path. This is thanks to
Haskell’s laziness – we can inspect partial solutions of the TSP problem
without demanding the whole thing. Best of all, once we inspect the initial
path, we never have to compute it again – the value of <code>tsp</code> at this path is
cached, so long as we access it through <code>exampleTsp</code>.</p>
<pre class="console"><code>*Main&gt; currentSolution exampleTsp
817.0</code></pre>
<h2 id="hitting-the-metal">Hitting the metal</h2>
<p>So we now have a data structure in which to express a set of solutions along
with a chosen solution and a strategy to search this set for a good enough
solution. The only things we still need are one function to slightly perturb a
solution and one to randomize it fully.</p>
<p>First, we’ll write a function to slightly perturb. We’ll consider a solution a
slight perturbation of the current one if it chooses a different subtree at
exactly <em>one</em> point in the current path. We’ll use <code>degreesOfFreedom</code> to figure out
where to choose a different path. We’ll call these perturbations <em>neighbors</em>
since they are “next” to the current solution.</p>
<p>We’ll use <code>RandomGen</code> from <code>System.Random</code> to abstract over our random generator.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="ot">pickNeighbor ::</span> <span class="dt">RandomGen</span> g <span class="ot">=&gt;</span> <span class="dt">Combinatorial</span> a <span class="ot">-&gt;</span> g <span class="ot">-&gt;</span> (<span class="dt">Combinatorial</span> a, g)</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>pickNeighbor c g <span class="ot">=</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> dof <span class="ot">=</span> degreesOfFreedom c</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>      (forkAt, g') <span class="ot">=</span> randomR (<span class="dv">0</span>, dof <span class="op">-</span> <span class="dv">1</span>) g</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span> (neighborAt forkAt c, g')</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a><span class="ot">neighborAt ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Combinatorial</span> a <span class="ot">-&gt;</span> <span class="dt">Combinatorial</span> a</span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>neighborAt _ c<span class="op">@</span>(<span class="dt">Leaf</span> {}) <span class="ot">=</span> c</span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>neighborAt i (<span class="dt">Choice</span> sz next rest)</span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> i <span class="op">&lt;</span> sz <span class="ot">=</span> <span class="kw">let</span> next' <span class="ot">=</span> neighborAt i next</span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a>             <span class="kw">in</span> <span class="dt">Choice</span> (degreesOfFreedom next') next' rest</span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span></span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> restIdx <span class="ot">=</span> i <span class="op">-</span> sz</span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a>          (restBefore, next'<span class="op">:</span>restAfter) <span class="ot">=</span> <span class="fu">splitAt</span> restIdx rest</span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-16"><a href="#cb31-16" aria-hidden="true" tabindex="-1"></a>          rest' <span class="ot">=</span> next<span class="op">:</span>(restBefore <span class="op">++</span> restAfter)</span>
<span id="cb31-17"><a href="#cb31-17" aria-hidden="true" tabindex="-1"></a>      <span class="kw">in</span> <span class="dt">Choice</span> (degreesOfFreedom next') next' rest'</span></code></pre></div>
<p>Now, to randomize a given solution, we’ll just choose a random neighbor an
arbitrary number of times.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="ot">randomize ::</span> <span class="dt">RandomGen</span> g <span class="ot">=&gt;</span> <span class="dt">Combinatorial</span> a <span class="ot">-&gt;</span> g <span class="ot">-&gt;</span> (<span class="dt">Combinatorial</span> a, g)</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>randomize c g <span class="ot">=</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> (numRandomizations, g') <span class="ot">=</span> randomR (<span class="dv">0</span>, degreesOfFreedom c) g</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>      randomizeNTimes <span class="dv">0</span> c g'' <span class="ot">=</span> (c, g'')</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>      randomizeNTimes n c g'' <span class="ot">=</span></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> (c', g''') <span class="ot">=</span> pickNeighbor c g''</span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">in</span> randomizeNTimes (n <span class="op">-</span> <span class="dv">1</span>) c' g'''</span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span> randomizeNTimes numRandomizations c g'</span></code></pre></div>
<p>We are all set!</p>
<p>We can now define an <code>anneal</code> function that – given a <code>Combinatorial</code> and
parameters for the annealing process – chooses a best guess. We’ll need to
provide a random generator as well</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Temperature</span> <span class="ot">=</span> <span class="dt">Double</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="ot">anneal ::</span> ( <span class="dt">RandomGen</span> g )</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>       <span class="ot">=&gt;</span> ( energy <span class="ot">-&gt;</span> energy <span class="ot">-&gt;</span> <span class="dt">Ordering</span>)</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>       <span class="ot">-&gt;</span> ( energy <span class="ot">-&gt;</span> energy <span class="ot">-&gt;</span> <span class="dt">Temperature</span> <span class="ot">-&gt;</span> <span class="dt">Double</span>) <span class="co">-- ^ Probability of accepting a worse solution</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>       <span class="ot">-&gt;</span> <span class="dt">Temperature</span> <span class="co">-- ^ Starting temperature</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>       <span class="ot">-&gt;</span> <span class="dt">Temperature</span> <span class="co">-- ^ Ending temperature</span></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>       <span class="ot">-&gt;</span> <span class="dt">Double</span> <span class="co">-- ^ Cooling factor</span></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>       <span class="ot">-&gt;</span> <span class="dt">Combinatorial</span> energy <span class="ot">-&gt;</span> g <span class="ot">-&gt;</span> (<span class="dt">Combinatorial</span> energy, g)</span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>anneal cmp acceptanceProbability tInitial tFinal coolingFactor initialSolution g <span class="ot">=</span></span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> (initial', g') <span class="ot">=</span> randomize initialSolution g</span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a>      doAnneal curTemp current best curRandom</span>
<span id="cb33-13"><a href="#cb33-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span> curTemp <span class="op">&lt;=</span> tFinal <span class="ot">=</span> (best, curRandom)</span>
<span id="cb33-14"><a href="#cb33-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span></span>
<span id="cb33-15"><a href="#cb33-15" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> (neighbor, curRandom') <span class="ot">=</span> pickNeighbor current curRandom</span>
<span id="cb33-16"><a href="#cb33-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-17"><a href="#cb33-17" aria-hidden="true" tabindex="-1"></a>                currentValue <span class="ot">=</span> currentSolution current</span>
<span id="cb33-18"><a href="#cb33-18" aria-hidden="true" tabindex="-1"></a>                neighborValue <span class="ot">=</span> currentSolution neighbor</span>
<span id="cb33-19"><a href="#cb33-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-20"><a href="#cb33-20" aria-hidden="true" tabindex="-1"></a>                (diceRoll, curRandom'') <span class="ot">=</span> randomR (<span class="dv">0</span>, <span class="dv">1</span>) curRandom'</span>
<span id="cb33-21"><a href="#cb33-21" aria-hidden="true" tabindex="-1"></a>                acceptNeighbor <span class="ot">=</span> cmp neighborValue currentValue <span class="op">==</span> <span class="dt">LT</span> <span class="op">||</span></span>
<span id="cb33-22"><a href="#cb33-22" aria-hidden="true" tabindex="-1"></a>                                 acceptanceProbability currentValue neighborValue curTemp <span class="op">&gt;</span> diceRoll</span>
<span id="cb33-23"><a href="#cb33-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-24"><a href="#cb33-24" aria-hidden="true" tabindex="-1"></a>                (current', current'Value) <span class="ot">=</span></span>
<span id="cb33-25"><a href="#cb33-25" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">if</span> acceptNeighbor</span>
<span id="cb33-26"><a href="#cb33-26" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">then</span> (neighbor, neighborValue)</span>
<span id="cb33-27"><a href="#cb33-27" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">else</span> (current, currentValue)</span>
<span id="cb33-28"><a href="#cb33-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-29"><a href="#cb33-29" aria-hidden="true" tabindex="-1"></a>                best' <span class="ot">=</span> <span class="kw">if</span> cmp current'Value (currentSolution best) <span class="op">==</span> <span class="dt">LT</span></span>
<span id="cb33-30"><a href="#cb33-30" aria-hidden="true" tabindex="-1"></a>                        <span class="kw">then</span> current'</span>
<span id="cb33-31"><a href="#cb33-31" aria-hidden="true" tabindex="-1"></a>                        <span class="kw">else</span> best</span>
<span id="cb33-32"><a href="#cb33-32" aria-hidden="true" tabindex="-1"></a>            <span class="kw">in</span> doAnneal (curTemp <span class="op">*</span> (<span class="dv">1</span> <span class="op">-</span> coolingFactor)) current' best' curRandom''</span>
<span id="cb33-33"><a href="#cb33-33" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span> doAnneal tInitial initial' initial' g'</span>
<span id="cb33-34"><a href="#cb33-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-35"><a href="#cb33-35" aria-hidden="true" tabindex="-1"></a><span class="ot">defaultAcceptanceProbability ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Temperature</span> <span class="ot">-&gt;</span> <span class="dt">Double</span></span>
<span id="cb33-36"><a href="#cb33-36" aria-hidden="true" tabindex="-1"></a>defaultAcceptanceProbability curValue neighborValue curTemp <span class="ot">=</span></span>
<span id="cb33-37"><a href="#cb33-37" aria-hidden="true" tabindex="-1"></a>  <span class="fu">exp</span> (<span class="op">-</span>(neighborValue <span class="op">-</span> curValue)<span class="op">/</span>(curValue <span class="op">*</span> curTemp))</span></code></pre></div>
<p>Now we can solve our traveling salesman problem stochastically. First, a utility
function to run the annealing in the <code>IO</code> monad using a new random generator.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="ot">runAnneal ::</span> <span class="dt">Temperature</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Double</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>runAnneal tInitial <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>  g <span class="ot">&lt;-</span> newStdGen</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> (result, _) <span class="ot">=</span> anneal <span class="fu">compare</span> defaultAcceptanceProbability tInitial <span class="dv">1</span> <span class="fl">0.003</span> exampleTsp g</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> (currentSolution result)</span></code></pre></div>
<p>Running it gives (results will obviously vary due to randomness):</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">Main</span><span class="op">&gt;</span> runAnneal <span class="dv">100000</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a><span class="fl">488.0</span></span></code></pre></div>
<p>This is certainly better than the naïve solution of visiting every city in order:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">Main</span><span class="op">&gt;</span> <span class="fu">head</span> (tsp allCities distFunc)</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="fl">817.0</span></span></code></pre></div>
<h2 id="asking-for-directions">Asking for directions</h2>
<p>Because <code>Combinatorial</code> is a <code>Monad</code>, we can use all the normal
<code>Monad</code> tricks. For example, if we want to get the path along with the
length, we can use <code>MonadWriter</code>.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="ot">tspWithPath ::</span> [ <span class="dt">City</span> ] <span class="ot">-&gt;</span> (<span class="dt">City</span> <span class="ot">-&gt;</span> <span class="dt">City</span> <span class="ot">-&gt;</span> <span class="dt">Double</span>)</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>            <span class="ot">-&gt;</span> <span class="dt">WriterT</span> [<span class="dt">City</span>] <span class="dt">Combinatorial</span> <span class="dt">Double</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>tspWithPath [] _ <span class="ot">=</span> <span class="fu">pure</span> <span class="dv">0</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>tspWithPath (firstCity<span class="op">:</span>cities) distance <span class="ot">=</span> go <span class="dv">0</span> firstCity cities</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>    go curDistance lastCity [] <span class="ot">=</span> <span class="fu">pure</span> (distance firstCity lastCity <span class="op">+</span> curDistance)</span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>    go curDistance lastCity unvisited <span class="ot">=</span></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a>      <span class="kw">do</span> nextCity <span class="ot">&lt;-</span> lift (choose unvisited)</span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a>         tell [nextCity]</span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true" tabindex="-1"></a>         <span class="kw">let</span> unvisited' <span class="ot">=</span> <span class="fu">filter</span> (<span class="op">/=</span>nextCity) unvisited</span>
<span id="cb37-12"><a href="#cb37-12" aria-hidden="true" tabindex="-1"></a>         go (curDistance <span class="op">+</span> distance nextCity lastCity) nextCity unvisited'</span>
<span id="cb37-13"><a href="#cb37-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-14"><a href="#cb37-14" aria-hidden="true" tabindex="-1"></a><span class="ot">exampleTspWithPath ::</span> <span class="dt">Combinatorial</span> (<span class="dt">Double</span>, [<span class="dt">City</span>])</span>
<span id="cb37-15"><a href="#cb37-15" aria-hidden="true" tabindex="-1"></a>exampleTspWithPath <span class="ot">=</span> runWriterT (tspWithPath allCities distFunc)</span>
<span id="cb37-16"><a href="#cb37-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-17"><a href="#cb37-17" aria-hidden="true" tabindex="-1"></a><span class="ot">runAnnealWithPath ::</span> <span class="dt">Temperature</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Double</span>, [<span class="dt">City</span>])</span>
<span id="cb37-18"><a href="#cb37-18" aria-hidden="true" tabindex="-1"></a>runAnnealWithPath tInitial <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb37-19"><a href="#cb37-19" aria-hidden="true" tabindex="-1"></a>  g <span class="ot">&lt;-</span> newStdGen</span>
<span id="cb37-20"><a href="#cb37-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> (result, _) <span class="ot">=</span> anneal (comparing <span class="fu">fst</span>) (defaultAcceptanceProbability <span class="ot">`on`</span> <span class="fu">fst</span>)</span>
<span id="cb37-21"><a href="#cb37-21" aria-hidden="true" tabindex="-1"></a>                           tInitial <span class="dv">1</span> <span class="fl">0.003</span> exampleTspWithPath g</span>
<span id="cb37-22"><a href="#cb37-22" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> (currentSolution result)</span></code></pre></div>
<p>Of course, we can inspect the default solution without waiting for the universe to end</p>
<pre class="console"><code>*Main&gt; currentSolution exampleTspWithPath
(817.0,[1,2,3,4,5,6,7,8,9,10,11,12,13,14])</code></pre>
<p>Running this we get</p>
<pre class="console"><code>*Main&gt; runAnnealWithPath 100000
(465.0,[10,5,3,12,1,2,6,8,4,7,9,11,13,14])</code></pre>
<h2 id="discussion">Discussion</h2>
<p>In this article, we developed an intuition to express combinatorial optimization
problems using monadic flattening. We then demonstrated two concrete monads
which are of interest when solving optimization problems. We saw that choosing
lists as our <code>Combinatorial</code> monad let us evaluate an optimization problem by
examining every possible value of the objective function. We saw that our own
custom <code>Combinatorial</code> monad allowed us to think of the set of solutions as a
tree which can be searched through lazily. Finally, we used simulated annealing
to search through the tree to achieve good enough optimizations of arbitrary
problems.</p>
<p>Our annealing function is not limited to traveling salesman problems. We can
encode any NP-complete problem where we can form an appropriate optimization
metric. This is not just of theoretical significance. Database engines, for
example, face the issue of join ordering for optimal query performance. Our
little framework provides a way to describe these problems, and then to evaluate
them fully when the search space is small or use an appropriate search method
when they become intractable. This is similar to how RDBMSes like PostgreSQL
optimize joins.</p>
<p>Because our tree structure comes with monadic operations, we don’t need to worry
about coming up with specific representations of these problems, as libraries in
other languages require. For example, the equivalent problem encoded in C using
a <a href="https://www.gnu.org/software/gsl/doc/html/siman.html">standard simulated annealing
library</a> takes up almost
70 lines of code. In contrast, ours (the implementation of <code>tsp</code>) took only
eleven, and could likely be simplified even more.</p>
<p>There are a few problems with our solution. First of all, we haven’t proven any
kind of convergence to an optimal solution. Secondly, our data structure keeps
around solutions which we’ve visited, but are known to be non-optimal. We could
be smarter in allowing these solutions to be garbage collected and marked as
inaccessible (a form of tabu search), or change our representation entirely to
avoid this. It remains to be seen if this is useful.</p>
<h2 id="future-work">Future work</h2>
<p>Our tree-like structure for representing combinations can be thought of as
containing the entire set of (as-yet uncomputed) solutions. In this article, we
used simulated annealing to search through this structure for an optimal
solution. However, there are multiple other strategies (termed
<em>meta-heuristics</em>) we could use. It’s an interesting exercise for the reader to
implement other search strategies, such as genetic algorithms, particle swarm
optimization, or ant colony optimization. The possibilities are as endless as
the possible paths through our fifteen cities!</p>
<p>Another interesting exploration would be to figure out what kinds of problems
could be encoded using monads versus applicative. Above, we saw that the
traveling salesman problem (which was NP-complete) requires the monadic bind. We
expressed <code>simpleOpt</code> using monadic operations, but it could easily have been
written using applicative. Part of me feels like there must be some interesting
differences between those problems that need only applicatives, versus those
that need monads.</p>
<p>These are thoughts for another day.</p>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>I’ll leave proving that these are valid instances up to the reader.
Hint: <code>Combinatorial</code> can be expressed as a free monad over a simple base functor<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</div>

<div id="disqus_thread"></div>
<script type="text/javascript">
/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
var disqus_shortname = 'travisathougiessblog'; // required: replace example with your forum shortname

/* * * DON'T EDIT BELOW THIS LINE * * */
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

        </div>
        <!-- Google Analytics Tracking -->
        <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-55204994-1', 'auto');
        ga('send', 'pageview');

        </script>
    </body>
</html>
