<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0" />
        <title>Travis Athougies - The monadic structure of combinatorial optimization</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
        <link rel="stylesheet" type="text/css" href="../css/jquery.modal.css" />
        <link href="http://fonts.googleapis.com/css?family=Open+Sans:400,300,800,700" rel="stylesheet" type="text/css">
        <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/javascript" src="../js/jquery.min.js"></script>
        <script type"text javascript" src="../js/jquery.modal.min.js"></script>
	<script type="text/javascript" src="../js/isotope.min.js"></script>
	<script type="text/javascript" src="../js/imagesloaded.min.js"></script>
        <script type="text/javascript" src="../js/gallery.js"></script>
    </head>
    <body>
        <div id="mini-header-bar">
          <div id="show-header">
            ☰
          </div>
          <h1 id="mini-logo">
            <a href="../"><p class="travis">Travis</p><p>Athougies</p></a>
          </h1>
        </div>
        <div id="gallery-modal" class="modal" style="display: hidden">
          <a href="#" id="gallery-prev"></a>
          <a href="#" id="gallery-next"></a>
          <img id="gallery-image" src="#" />
          <div id="gallery-caption">
            <span class="gallery-figure">Figure <span id="figure-number">0</span> &mdash;</span><span id="caption-text"></span>
          </div>
        </div>
        <div id="header">
            <h1 id="logo">
                <a href="../"><p class="travis">Travis</p><p>Athougies</p></a>
            </h1>
            <div id="taglines">
              technologist
              dreamer
              builder
            </div>
            <ul id="navigation">
              <li><h2>Navigation</h2>
                <ul>
                  <li><a href="../">Home</a></li>
                  <li><a href="../about.html">About</a></li>
                  <li><a href="../projects.html">Projects</a></li>
                  <li><a href="../contact.html">Contact</a></li>
                  <li><a href="../archive.html">Archive</a></li>
                </ul></li>
              <li><h2>Tags</h2>
                <ul>
                
                  <li><a href="../tags/haskell.html">haskell (14)</a></li>
                
                  <li><a href="../tags/hydroponics.html">hydroponics (9)</a></li>
                
                  <li><a href="../tags/sustainability.html">sustainability (5)</a></li>
                
                  <li><a href="../tags/gardening.html">gardening (4)</a></li>
                
                  <li><a href="../tags/beam.html">beam (3)</a></li>
                
                  <li><a href="../tags/web.html">web (2)</a></li>
                
                  <li><a href="../tags/math.html">math (2)</a></li>
                
                  <li><a href="../tags/hakyll.html">hakyll (1)</a></li>
                
                  <li><a href="../tags/food.html">food (1)</a></li>
                
                  <li><a href="../tags/finance.html">finance (1)</a></li>
                
                  <li><a href="../tags/databases.html">databases (1)</a></li>
                
                  <li><a href="../tags/business.html">business (1)</a></li>
                
                  <li><a href="../tags/agriculture.html">agriculture (1)</a></li>
                </ul></li>
            </ul>
          <div id="shamelessplug">
              Site proudly generated by
              <a href="http://jaspervdj.be/hakyll">Hakyll</a> <p></p>
              This site kept updated by <a href="http://travis-ci.org">Travis CI</a> <p></p>
              <img src="https://travis-ci.org/tathougies/travis-athougies-blog.svg?branch=master" />
          </div>
        </div>

        <div id="content">
            <h1>The monadic structure of combinatorial optimization</h1>

            <div class="info">
    Posted on <span class="date">April 23, 2018</span>
    
        by <span class="author">Travis Athougies</span>
    
</div>
<div class="tags">
  in
  <ul>
    
    <li><a href="../tags/haskell.html">haskell</a></li>
    
    <li><a href="../tags/math.html">math</a></li>
    
  </ul>
</div>



<div id="post">
<p>Combinatorial optimization refers to assigning discrete values to a set of variables with the aim to minimize (or equivalently, maximize) a given objective function.</p>
<p>In general, a combinatorial optimization problem has the form:</p>
<p>\[ \begin{aligned} &amp; \underset{v_1,v_2, \ldots v_n}{\text{minimize}} &amp; &amp; f(v_1, v_2, \ldots v_n) \\ &amp; \text{subject to} &amp; &amp; v_1 \in D_1, v_2 \in D_2, \ldots v_n \in D_n \end{aligned} \]</p>
<p>Here, <span class="math inline">\(f\)</span> is called the objective function. The <span class="math inline">\(v_i\)</span> are the variables we’re optimizing over and the <span class="math inline">\(D_i\)</span> are the corresponding domains. The solution to the problem is the lowest possible value of <span class="math inline">\(f(v_i,v_2,\ldots v_n)\)</span> where all the <span class="math inline">\(v_i\)</span> are within their corresponding domain.</p>
<p>In the mathematical notation above, our <span class="math inline">\(f\)</span> takes <span class="math inline">\(n\)</span> arguments. In Haskell, functions only take one argument and return one value. We can achieve higher-arity functions by writing functions that return functions.</p>
<p>We can extend this concept to our optimization problems. We’ll restrict each optimization problem to optimize over only one variable:</p>
<p>\[ \begin{aligned} &amp; \underset{v_1}{\text{minimize}} &amp; &amp; f(v_1) \\ &amp; \text{subject to} &amp; &amp; v_1 \in D_1 \end{aligned} \]</p>
<p>To support multiple variables, we’ll just have our objective function return another optimization problem:</p>
<p>\[ \begin{aligned} &amp; \underset{v_1}{\text{minimize}} &amp; \underset{v_2}{\text{minimize }} &amp; f(v_1)(v_2) \\ &amp; &amp; \text{subject to } &amp; v_2 \in D_2 \\ &amp; \text{subject to} &amp; v_1 \in D_1 \end{aligned} \]</p>
<p>Notice that the inner minimization problem is simply a function over <span class="math inline">\(v_1\)</span>:</p>
<p>\[ f_{inner}(v_1) = \begin{aligned} &amp; \underset{v_2}{\text{minimize}} &amp; &amp; f_{orig} (v_1)(v_2) \\ &amp; \text{subject to} &amp; &amp; v_2 \in D_2 \end{aligned} \]</p>
<p>Intuitively, we can optimize over numbers, because numbers have a total ordering. We should consider whether it’s meaningful to optimize over optimization problems as well. Otherwise, it would be meaningless to nest problems in this way.</p>
<p>As a rough sketch, we’ll consider optimization problem <span class="math inline">\(A\)</span> to be less than <span class="math inline">\(B\)</span> if the minimum value achievable in <span class="math inline">\(A\)</span> is less than <span class="math inline">\(B\)</span>. Intuitively, if we evaluate a deeply nested set of problems using this ordering, we must arrive at the minimum value achievable in the equivalent multi-variate problems. Writing out a formal proof is left as an exercise to the reader.</p>
<h2 id="there-and-back-again">There and back again</h2>
<p>We’ve developed an intuition to convert multi-variate optimization problems to univariate ones by nesting them. Let’s see if we can encode these problems in Haskell.</p>
<p>First, let’s consider a particular optimization problem. Here’s a simple one to start.</p>
<p>\[ \begin{aligned} &amp; \underset{x, y}{\text{minimize}} &amp; &amp; x + y \\ &amp; \text{subject to} &amp; &amp; x \in \{ 1, 2 \}, y \in \{ 3, 4 \} \end{aligned} \]</p>
<p>Writing this in our univariate style:</p>
<p>\[ \begin{aligned} &amp; \underset{x}{\text{minimize}} &amp; &amp; f_{next} (x) \\ &amp; \text{subject to} &amp; &amp; x \in \{ 1, 2 \} \end{aligned} \]</p>
<p>\[ f_{next} (x) = \begin{aligned} &amp; \underset{y}{\text{minimize}} &amp; &amp; x + y \\ &amp; \text{subject to} &amp; &amp; y \in \{ 3, 4 \} \end{aligned} \]</p>
<p>For our Haskell representation, we’ll presume the existence of a type (<code>Combinatorial</code>) that represents an optimization problem that minimizes a value in a particular domain. We can construct a problem using a new combinator, called <code>choose</code>, that takes in the domain and the objective function.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">choose ::</span> [a] <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Combinatorial</span> b</a></code></pre></div>
<p>In order to actually run our optimization, let’s suppose we have a function</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">optimize ::</span> <span class="dt">Combinatorial</span> b <span class="ot">-&gt;</span> b</a></code></pre></div>
<p>Now we can encode the problem above:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">fNext ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Combinatorial</span> <span class="dt">Double</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">fNext x <span class="fu">=</span> choose [<span class="dv">3</span>,<span class="dv">4</span>] (\y <span class="ot">-&gt;</span> x <span class="fu">+</span> y)</a>
<a class="sourceLine" id="cb3-3" data-line-number="3"></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="ot">optProblem ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Combinatorial</span> (<span class="dt">Combinatorial</span> <span class="dt">Double</span>)</a>
<a class="sourceLine" id="cb3-5" data-line-number="5">optProblem <span class="fu">=</span> choose [<span class="dv">1</span>,<span class="dv">2</span>] fNext</a></code></pre></div>
<p>Note that, if we specialize <code>optimize</code> to the return type of <code>optProblem</code>, we get</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">optimize ::</span> <span class="dt">Combinatorial</span> (<span class="dt">Combinatorial</span> b) <span class="ot">-&gt;</span> <span class="dt">Combinatorial</span> b</a></code></pre></div>
<p>Astute readers will notice that this function has the same type as an old friend: <code>join</code>.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">join ::</span> <span class="dt">Monad</span> f <span class="ot">=&gt;</span> f (f a) <span class="ot">-&gt;</span> f a</a></code></pre></div>
<p>Recall that a type forms a monad, if it forms functor and has sensible implementations of <code>join</code> and <code>pure</code>. Above, we saw that <code>join</code> is like <code>optimize</code>. We can think of <code>pure</code> as the trivial optimization problem where <span class="math inline">\(f\)</span> is the identity function and the domain contains only one value.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1">pure<span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Combinatorial</span> a</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">pure x <span class="fu">=</span> choose [x] id</a></code></pre></div>
<p>Finally, a functor needs to have a function <code>fmap</code>.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1">fmap<span class="ot"> ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</a></code></pre></div>
<p>For <code>Combinatorial</code>, this is just the function that composes the objective function. In other words, it turns</p>
<p>\[ \begin{aligned} &amp; \underset{v_1}{\text{minimize}} &amp; &amp; g(v_1) \\ &amp; \text{subject to} &amp; &amp; v_1 \in D_1 \end{aligned} \]</p>
<p>into</p>
<p>\[ \begin{aligned} &amp; \underset{v_1}{\text{minimize}} &amp; &amp; f(g(v_1)) \\ &amp; \text{subject to} &amp; &amp; v_1 \in D_1 \end{aligned} \]</p>
<p>With that in place, we can actually get rid of the second argument in <code>choose</code>. Let’s define a new combinator, called <code>domain</code>.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ot">domain ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Combinatorial</span> a</a></code></pre></div>
<p>Now we can write <code>choose</code> in terms of <code>domain</code> and <code>fmap</code>.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">choose ::</span> [a] <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Combinatorial</span> a</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">choose d f <span class="fu">=</span> fmap f (domain d)</a></code></pre></div>
<p>So, in other words, <code>Combinatorial</code> needs to have only three fundamental operations.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="ot">domain ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Combinatorial</span> a</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">fmap<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Combinatorial</span> a <span class="ot">-&gt;</span> <span class="dt">Combinatorial</span> b</a>
<a class="sourceLine" id="cb10-3" data-line-number="3"><span class="ot">join ::</span> <span class="dt">Combinatorial</span> (<span class="dt">Combinatorial</span> a) <span class="ot">-&gt;</span> <span class="dt">Combinatorial</span> a</a></code></pre></div>
<h2 id="lets-get-real">Let’s get real</h2>
<p>Enough theory. Let’s actually do this.</p>
<p>This file is <a href="https://github.com/tathougies/travis-athougies-blog/blob/master/site-content/posts/2018-04-23-combinatorial-optimization.lhs">Literate Haskell</a>, so we’ll need some imports and two extensions.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="ot">{-# LANGUAGE DeriveFunctor #-}</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2"><span class="ot">{-# LANGUAGE FlexibleContexts #-}</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Control.Monad</span> (ap)</a>
<a class="sourceLine" id="cb11-4" data-line-number="4"><span class="kw">import</span> <span class="dt">Control.Monad.Trans</span> (lift)</a>
<a class="sourceLine" id="cb11-5" data-line-number="5"><span class="kw">import</span> <span class="dt">Control.Monad.Writer</span> (<span class="dt">WriterT</span>, runWriterT, tell)</a>
<a class="sourceLine" id="cb11-6" data-line-number="6"><span class="kw">import</span> <span class="dt">Data.Ord</span> (comparing)</a>
<a class="sourceLine" id="cb11-7" data-line-number="7"><span class="kw">import</span> <span class="dt">Data.Function</span> (on)</a>
<a class="sourceLine" id="cb11-8" data-line-number="8"><span class="kw">import</span> <span class="dt">System.Random</span></a></code></pre></div>
<p>We need to find some concrete Haskell type for which we can implement <code>domain</code> and <code>fmap</code>. An obvious choice for this is list. Here,</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="ot">domain ::</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">domain <span class="fu">=</span> id</a></code></pre></div>
<p>and <code>fmap</code> is from the standard <code>Functor</code> instance for list and <code>join</code> is from the standard <code>Monad</code> instance.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1">fmap<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">fmap <span class="fu">=</span> map</a>
<a class="sourceLine" id="cb13-3" data-line-number="3"></a>
<a class="sourceLine" id="cb13-4" data-line-number="4"><span class="ot">join ::</span> [ [a] ] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb13-5" data-line-number="5">join <span class="fu">=</span> concat</a></code></pre></div>
<p>Going back to our original problem, we can express it using lists:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="ot">simpleOpt ::</span> [<span class="dt">Double</span>]</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">simpleOpt <span class="fu">=</span></a>
<a class="sourceLine" id="cb14-3" data-line-number="3"> <span class="kw">do</span> x <span class="ot">&lt;-</span> [<span class="dv">1</span>, <span class="dv">2</span>]</a>
<a class="sourceLine" id="cb14-4" data-line-number="4">    y <span class="ot">&lt;-</span> [<span class="dv">3</span>, <span class="dv">4</span>]</a>
<a class="sourceLine" id="cb14-5" data-line-number="5">    pure (x <span class="fu">+</span> y)</a></code></pre></div>
<p>Now, we can find the minimum using the <code>minimum</code> function. This is equivalent to <code>optimize</code> but requires its argument to have an <code>Ord</code> instance.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1">minimum<span class="ot"> ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb15-2" data-line-number="2"><span class="ot">optimize ::</span> <span class="dt">Combinatorial</span> a <span class="ot">-&gt;</span> a</a></code></pre></div>
<p>Running <code>minimum</code> on our example:</p>
<pre class="console"><code>Main*&gt; minimum simpleOpt
4.0</code></pre>
<p>The list monad causes us to consider every solution. If we print out the value of <code>simpleOpt</code>, we’ll see that it is a list containing every possible outcome of our objective function</p>
<pre class="console"><code>*Main&gt; simpleOpt
[4.0,5.0,5.0,6.0]</code></pre>
<p>Evaluating every solution is the most straightforward way to solve these problems, but it quickly becomes intractable as the problems get larger.</p>
<p>For example, the <a href="http://katrinaeg.com/simulated-annealing.html">traveling salesman problem</a> asks us to find the length of the shortest route through a given set of cities, visiting each city only once, and returning to the original city. Here, our next choice of city depends on which cities we’ve already visited.</p>
<p>We can use the list monad to formulate every possible solution to an arbitrary traveling salesman problem.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="kw">type</span> <span class="dt">City</span> <span class="fu">=</span> <span class="dt">Int</span> <span class="co">-- use Int to represent a city, for now</span></a>
<a class="sourceLine" id="cb18-2" data-line-number="2"></a>
<a class="sourceLine" id="cb18-3" data-line-number="3"><span class="ot">tsp ::</span> [ <span class="dt">City</span> ] <span class="ot">-&gt;</span> (<span class="dt">City</span> <span class="ot">-&gt;</span> <span class="dt">City</span> <span class="ot">-&gt;</span> <span class="dt">Double</span>)</a>
<a class="sourceLine" id="cb18-4" data-line-number="4">    <span class="ot">-&gt;</span> [ <span class="dt">Double</span> ]</a>
<a class="sourceLine" id="cb18-5" data-line-number="5">tsp [] _ <span class="fu">=</span> pure <span class="dv">0</span></a>
<a class="sourceLine" id="cb18-6" data-line-number="6">tsp (firstCity<span class="fu">:</span>cities) distance <span class="fu">=</span> go <span class="dv">0</span> firstCity cities</a>
<a class="sourceLine" id="cb18-7" data-line-number="7">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-8" data-line-number="8">    go curDistance lastCity [] <span class="fu">=</span> pure (distance firstCity lastCity <span class="fu">+</span> curDistance)</a>
<a class="sourceLine" id="cb18-9" data-line-number="9">    go curDistance lastCity unvisited <span class="fu">=</span></a>
<a class="sourceLine" id="cb18-10" data-line-number="10">      <span class="kw">do</span> nextCity <span class="ot">&lt;-</span> unvisited</a>
<a class="sourceLine" id="cb18-11" data-line-number="11"></a>
<a class="sourceLine" id="cb18-12" data-line-number="12">         <span class="kw">let</span> unvisited' <span class="fu">=</span> filter (<span class="fu">/=</span>nextCity) unvisited</a>
<a class="sourceLine" id="cb18-13" data-line-number="13">         go (curDistance <span class="fu">+</span> distance nextCity lastCity) nextCity unvisited'</a></code></pre></div>
<h2 id="solving-the-traveling-salesman-problem">Solving the Traveling Salesman Problem</h2>
<p>Let’s define an instance of the traveling salesman problem, with 15 cities. We’ll represent distances between the cities using a 15x15 distance matrix, encoded as nested lists (this example is meant to illustrate, not perform!).</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="ot">distMatrix ::</span> [ [ <span class="dt">Double</span> ] ]</a>
<a class="sourceLine" id="cb19-2" data-line-number="2">distMatrix <span class="fu">=</span></a>
<a class="sourceLine" id="cb19-3" data-line-number="3">  [ [  <span class="dv">0</span>, <span class="dv">29</span>, <span class="dv">82</span>, <span class="dv">46</span>, <span class="dv">68</span>, <span class="dv">52</span>, <span class="dv">72</span>, <span class="dv">42</span>, <span class="dv">51</span>, <span class="dv">55</span>, <span class="dv">29</span>, <span class="dv">74</span>, <span class="dv">23</span>, <span class="dv">72</span>, <span class="dv">46</span> ]</a>
<a class="sourceLine" id="cb19-4" data-line-number="4">  , [ <span class="dv">29</span>,  <span class="dv">0</span>, <span class="dv">55</span>, <span class="dv">46</span>, <span class="dv">42</span>, <span class="dv">43</span>, <span class="dv">43</span>, <span class="dv">23</span>, <span class="dv">23</span>, <span class="dv">31</span>, <span class="dv">41</span>, <span class="dv">51</span>, <span class="dv">11</span>, <span class="dv">52</span>, <span class="dv">21</span> ]</a>
<a class="sourceLine" id="cb19-5" data-line-number="5">  , [ <span class="dv">82</span>, <span class="dv">55</span>,  <span class="dv">0</span>, <span class="dv">68</span>, <span class="dv">46</span>, <span class="dv">55</span>, <span class="dv">23</span>, <span class="dv">43</span>, <span class="dv">41</span>, <span class="dv">29</span>, <span class="dv">79</span>, <span class="dv">21</span>, <span class="dv">64</span>, <span class="dv">31</span>, <span class="dv">51</span> ]</a>
<a class="sourceLine" id="cb19-6" data-line-number="6">  , [ <span class="dv">46</span>, <span class="dv">46</span>, <span class="dv">68</span>,  <span class="dv">0</span>, <span class="dv">82</span>, <span class="dv">15</span>, <span class="dv">72</span>, <span class="dv">31</span>, <span class="dv">62</span>, <span class="dv">42</span>, <span class="dv">21</span>, <span class="dv">51</span>, <span class="dv">51</span>, <span class="dv">43</span>, <span class="dv">64</span> ]</a>
<a class="sourceLine" id="cb19-7" data-line-number="7">  , [ <span class="dv">68</span>, <span class="dv">42</span>, <span class="dv">46</span>, <span class="dv">82</span>,  <span class="dv">0</span>, <span class="dv">74</span>, <span class="dv">23</span>, <span class="dv">52</span>, <span class="dv">21</span>, <span class="dv">46</span>, <span class="dv">82</span>, <span class="dv">58</span>, <span class="dv">46</span>, <span class="dv">65</span>, <span class="dv">23</span> ]</a>
<a class="sourceLine" id="cb19-8" data-line-number="8">  , [ <span class="dv">52</span>, <span class="dv">43</span>, <span class="dv">55</span>, <span class="dv">15</span>, <span class="dv">74</span>,  <span class="dv">0</span>, <span class="dv">61</span>, <span class="dv">23</span>, <span class="dv">55</span>, <span class="dv">31</span>, <span class="dv">33</span>, <span class="dv">37</span>, <span class="dv">51</span>, <span class="dv">29</span>, <span class="dv">59</span> ]</a>
<a class="sourceLine" id="cb19-9" data-line-number="9">  , [ <span class="dv">72</span>, <span class="dv">43</span>, <span class="dv">23</span>, <span class="dv">72</span>, <span class="dv">23</span>, <span class="dv">61</span>,  <span class="dv">0</span>, <span class="dv">42</span>, <span class="dv">23</span>, <span class="dv">31</span>, <span class="dv">77</span>, <span class="dv">37</span>, <span class="dv">51</span>, <span class="dv">46</span>, <span class="dv">33</span> ]</a>
<a class="sourceLine" id="cb19-10" data-line-number="10">  , [ <span class="dv">42</span>, <span class="dv">23</span>, <span class="dv">43</span>, <span class="dv">31</span>, <span class="dv">52</span>, <span class="dv">23</span>, <span class="dv">42</span>,  <span class="dv">0</span>, <span class="dv">33</span>, <span class="dv">15</span>, <span class="dv">37</span>, <span class="dv">33</span>, <span class="dv">33</span>, <span class="dv">31</span>, <span class="dv">37</span> ]</a>
<a class="sourceLine" id="cb19-11" data-line-number="11">  , [ <span class="dv">51</span>, <span class="dv">23</span>, <span class="dv">41</span>, <span class="dv">62</span>, <span class="dv">21</span>, <span class="dv">55</span>, <span class="dv">23</span>, <span class="dv">33</span>,  <span class="dv">0</span>, <span class="dv">29</span>, <span class="dv">62</span>, <span class="dv">46</span>, <span class="dv">29</span>, <span class="dv">51</span>, <span class="dv">11</span> ]</a>
<a class="sourceLine" id="cb19-12" data-line-number="12">  , [ <span class="dv">55</span>, <span class="dv">31</span>, <span class="dv">29</span>, <span class="dv">42</span>, <span class="dv">46</span>, <span class="dv">31</span>, <span class="dv">31</span>, <span class="dv">15</span>, <span class="dv">29</span>,  <span class="dv">0</span>, <span class="dv">51</span>, <span class="dv">21</span>, <span class="dv">41</span>, <span class="dv">23</span>, <span class="dv">37</span> ]</a>
<a class="sourceLine" id="cb19-13" data-line-number="13">  , [ <span class="dv">29</span>, <span class="dv">41</span>, <span class="dv">79</span>, <span class="dv">21</span>, <span class="dv">82</span>, <span class="dv">33</span>, <span class="dv">77</span>, <span class="dv">37</span>, <span class="dv">62</span>, <span class="dv">51</span>,  <span class="dv">0</span>, <span class="dv">65</span>, <span class="dv">42</span>, <span class="dv">59</span>, <span class="dv">61</span> ]</a>
<a class="sourceLine" id="cb19-14" data-line-number="14">  , [ <span class="dv">74</span>, <span class="dv">51</span>, <span class="dv">21</span>, <span class="dv">51</span>, <span class="dv">58</span>, <span class="dv">37</span>, <span class="dv">37</span>, <span class="dv">33</span>, <span class="dv">46</span>, <span class="dv">21</span>, <span class="dv">65</span>,  <span class="dv">0</span>, <span class="dv">61</span>, <span class="dv">11</span>, <span class="dv">55</span> ]</a>
<a class="sourceLine" id="cb19-15" data-line-number="15">  , [ <span class="dv">23</span>, <span class="dv">11</span>, <span class="dv">64</span>, <span class="dv">51</span>, <span class="dv">46</span>, <span class="dv">51</span>, <span class="dv">51</span>, <span class="dv">33</span>, <span class="dv">29</span>, <span class="dv">41</span>, <span class="dv">42</span>, <span class="dv">61</span>,  <span class="dv">0</span>, <span class="dv">62</span>, <span class="dv">23</span> ]</a>
<a class="sourceLine" id="cb19-16" data-line-number="16">  , [ <span class="dv">72</span>, <span class="dv">52</span>, <span class="dv">31</span>, <span class="dv">43</span>, <span class="dv">65</span>, <span class="dv">29</span>, <span class="dv">46</span>, <span class="dv">31</span>, <span class="dv">51</span>, <span class="dv">23</span>, <span class="dv">59</span>, <span class="dv">11</span>, <span class="dv">62</span>,  <span class="dv">0</span>, <span class="dv">59</span> ]</a>
<a class="sourceLine" id="cb19-17" data-line-number="17">  , [ <span class="dv">46</span>, <span class="dv">21</span>, <span class="dv">51</span>, <span class="dv">64</span>, <span class="dv">23</span>, <span class="dv">59</span>, <span class="dv">33</span>, <span class="dv">37</span>, <span class="dv">11</span>, <span class="dv">37</span>, <span class="dv">61</span>, <span class="dv">55</span>, <span class="dv">23</span>, <span class="dv">59</span>,  <span class="dv">0</span> ]</a>
<a class="sourceLine" id="cb19-18" data-line-number="18">  ]</a>
<a class="sourceLine" id="cb19-19" data-line-number="19"></a>
<a class="sourceLine" id="cb19-20" data-line-number="20"><span class="ot">distFunc ::</span> <span class="dt">City</span> <span class="ot">-&gt;</span> <span class="dt">City</span> <span class="ot">-&gt;</span> <span class="dt">Double</span></a>
<a class="sourceLine" id="cb19-21" data-line-number="21">distFunc a b <span class="fu">=</span> (distMatrix <span class="fu">!!</span> a) <span class="fu">!!</span> b</a>
<a class="sourceLine" id="cb19-22" data-line-number="22"></a>
<a class="sourceLine" id="cb19-23" data-line-number="23"><span class="ot">allCities ::</span> [ <span class="dt">City</span> ]</a>
<a class="sourceLine" id="cb19-24" data-line-number="24">allCities <span class="fu">=</span> [ <span class="dv">0</span> <span class="fu">..</span> <span class="dv">14</span> ]</a></code></pre></div>
<p>Solving <code>simpleOpt</code> was easy. Let’s see what happens if we attempt to minimize the value of <code>tsp</code> using the parameters above.</p>
<pre class="console"><code>*Main&gt; minimum (tsp allCities distFunc)
... Wait until end of universe ...
Profit!</code></pre>
<p>As you can see, not much happens. Under the hood, Haskell is busy calculating every single path, trying to find one that works. Sadly, there are trillions of paths, so this search will take a very long time. By the time we have 60 cities on our itinerary, we would have to examine more paths than there are particles in the known universe. Clearly, we need a better strategy.</p>
<h2 id="if-you-cant-solve-a-problem-guess">If you can’t solve a problem, guess</h2>
<p>Oftentimes, when problems like these come up in practice, we don’t need the <em>optimal</em> solution, and can move forward with any solution that’s <em>good enough</em>.</p>
<p><a href="https://en.wikipedia.org/wiki/Simulated_annealing">Simulated annealing</a> is one such strategy to find a good enough solution. It is inspired by the metallurgical process of <em>annealing</em>, whereby metal atoms are heated to high temperatures and then slowly cooled to increase the overall strength of the object.</p>
<p>The basic simulated annealing algorithm is as follows:</p>
<ol type="1">
<li>Choose an initial solution at random, and set a high temperature <span class="math inline">\(T\)</span>.</li>
<li>Repeat the following steps until the system has “cooled”:
<ol type="1">
<li>Select a random perturbation of the current solution</li>
<li><p>If the perturbation is better than the current solution, move towards it. Otherwise, randomly decide to move to the neighbor, with a probability proportional to <em>T</em>.</p>
<p>For the purposes of this article, we’ll accept a worse solution with probability</p>
<p>\[P(\text{choose worse}) = \exp\left(-\frac{1}{T}\left(\frac{f(neighbor) - f(current)}{f(current)}\right)\right)\]</p>
<p>where <span class="math inline">\(f\)</span> is the objective function.</p></li>
<li>Lower <span class="math inline">\(T\)</span> systematically.</li>
</ol></li>
<li>Return the best seen solution</li>
</ol>
<h2 id="laziness-for-the-win">Laziness for the win</h2>
<p>When we think of any combinatorial optimization problem, we soon realize that any solution can be thought of as a path from the root of a tree to any leaf.</p>
<p>For example, for <code>simpleOpt</code>, we can construct a tree representing choices for <code>x</code> and <code>y</code>.</p>
<p><div class="figure"><a href="../images/dot/comb-opt/simpleopt.png"><img src="../images/dot/comb-opt/simpleopt.png" alt="The tree for &lt;code&gt;simpleOpt&lt;/code&gt;. The highlighted path represents one possible solution: &lt;code&gt;x=1&lt;/code&gt; and &lt;code&gt;y=3&lt;/code&gt;." width="auto"></a><p class="caption">The tree for <code>simpleOpt</code>. The highlighted path represents one possible solution: <code>x=1</code> and <code>y=3</code>.</p></div></p>
<p>The traveling salesman tree is a lot larger, but is straightforwards to construct.</p>
<p><div class="figure"><a href="../images/dot/comb-opt/tsp.png"><img src="../images/dot/comb-opt/tsp.png" alt="The tree for &lt;code&gt;exampleTsp&lt;/code&gt;. The highlighted path represents one possible solution: &lt;code&gt;[0,1,2,..,12,13,14]&lt;/code&gt;." width="auto"></a><p class="caption">The tree for <code>exampleTsp</code>. The highlighted path represents one possible solution: <code>[0,1,2,..,12,13,14]</code>.</p></div></p>
<p>Note that the interior values associated with any particular choice are immaterial. All that matters is the structure of the edges. In the diagrams above, we notated each edge with the assignment it represents. The leaves are notated with solutions.</p>
<p>We can trivially encode such trees with a Haskell data type.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Combinatorial</span> a</a>
<a class="sourceLine" id="cb21-2" data-line-number="2">   <span class="fu">=</span> <span class="dt">Choice</span> <span class="dt">Int</span> (<span class="dt">Combinatorial</span> a) [<span class="dt">Combinatorial</span> a]</a>
<a class="sourceLine" id="cb21-3" data-line-number="3">   <span class="fu">|</span> <span class="dt">Leaf</span> a</a></code></pre></div>
<p>Here, <code>Choice</code> represents a node with children. It contains one privileged child (the next in our path) along with a list of children not in our path. The <code>Int</code> argument is simply the cached degrees of freedom of the next child (more on this later). As expected <code>Leaf</code> is simply a node with no children, that represents the final result of a choice.</p>
<p><code>Combinatorial</code> is trivially a <code>Functor</code>, and we can just ask GHC to figure that one out for us.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1">   <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Functor</span>)</a></code></pre></div>
<p>Let’s define a function to figure out the number of degrees of freedom in a given <code>Combinatorial</code>. This helps in choosing a random neighbor.</p>
<p>Firstly, a single value has no degrees of freedom</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="ot">degreesOfFreedom ::</span> <span class="dt">Combinatorial</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb23-2" data-line-number="2">degreesOfFreedom <span class="dt">Leaf</span> {} <span class="fu">=</span> <span class="dv">0</span></a></code></pre></div>
<p>A <code>Choice</code> has the degrees of freedom of its current child plus the possibilities of choosing one of its other subtrees.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1">degreesOfFreedom (<span class="dt">Choice</span> childSz _ remaining) <span class="fu">=</span> length remaining <span class="fu">+</span> childSz</a></code></pre></div>
<p>We can also write a function to get the solution at the chosen path.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1"><span class="ot">currentSolution ::</span> <span class="dt">Combinatorial</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb25-2" data-line-number="2">currentSolution (<span class="dt">Leaf</span> a) <span class="fu">=</span> a</a>
<a class="sourceLine" id="cb25-3" data-line-number="3">currentSolution (<span class="dt">Choice</span> _ next _) <span class="fu">=</span> currentSolution next</a></code></pre></div>
<p>A bit of thinking, and there are natural applicative and monadic interfaces <a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Combinatorial</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb26-2" data-line-number="2">  pure <span class="fu">=</span> <span class="dt">Leaf</span></a>
<a class="sourceLine" id="cb26-3" data-line-number="3">  (<span class="fu">&lt;*&gt;</span>) <span class="fu">=</span> ap</a>
<a class="sourceLine" id="cb26-4" data-line-number="4"></a>
<a class="sourceLine" id="cb26-5" data-line-number="5"><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Combinatorial</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb26-6" data-line-number="6">  return <span class="fu">=</span> pure</a>
<a class="sourceLine" id="cb26-7" data-line-number="7">  <span class="dt">Leaf</span> a <span class="fu">&gt;&gt;=</span> b <span class="fu">=</span> b a</a>
<a class="sourceLine" id="cb26-8" data-line-number="8">  <span class="dt">Choice</span> sz next rest <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span></a>
<a class="sourceLine" id="cb26-9" data-line-number="9">    <span class="kw">let</span> next' <span class="fu">=</span> next <span class="fu">&gt;&gt;=</span> f</a>
<a class="sourceLine" id="cb26-10" data-line-number="10">        sz'   <span class="fu">=</span> degreesOfFreedom next'</a>
<a class="sourceLine" id="cb26-11" data-line-number="11">    <span class="kw">in</span> <span class="dt">Choice</span> sz' next' (map (<span class="fu">&gt;&gt;=</span> f) rest)</a></code></pre></div>
<p>We can write a function to introduce non-determinism into <code>Combinatorial</code>. <code>choose</code> takes a non-empty list of possible values (the <em>domain</em>) of a variable; it yields the current choice. For the sake of simplicity, we <code>error</code> on an empty list, but a more robust solution would use <code>Data.List.NonEmpty</code> or another solution.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="ot">choose ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Combinatorial</span> a</a>
<a class="sourceLine" id="cb27-2" data-line-number="2">choose [] <span class="fu">=</span> error <span class="st">&quot;Empty domain&quot;</span></a>
<a class="sourceLine" id="cb27-3" data-line-number="3">choose [a] <span class="fu">=</span> <span class="dt">Leaf</span> a</a>
<a class="sourceLine" id="cb27-4" data-line-number="4">choose (a<span class="fu">:</span>as) <span class="fu">=</span> <span class="dt">Choice</span> <span class="dv">0</span> (<span class="dt">Leaf</span> a) (map <span class="dt">Leaf</span> as)</a></code></pre></div>
<p>Now, we can encode <code>tsp</code> in <code>Combinatorial</code>.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" data-line-number="1"><span class="ot">tspCombinatorial ::</span> [ <span class="dt">City</span> ] <span class="ot">-&gt;</span> (<span class="dt">City</span> <span class="ot">-&gt;</span> <span class="dt">City</span> <span class="ot">-&gt;</span> <span class="dt">Double</span>)</a>
<a class="sourceLine" id="cb28-2" data-line-number="2">                 <span class="ot">-&gt;</span> <span class="dt">Combinatorial</span> <span class="dt">Double</span></a>
<a class="sourceLine" id="cb28-3" data-line-number="3">tspCombinatorial [] _ <span class="fu">=</span> pure <span class="dv">0</span></a>
<a class="sourceLine" id="cb28-4" data-line-number="4">tspCombinatorial (firstCity<span class="fu">:</span>cities) distance <span class="fu">=</span> go <span class="dv">0</span> firstCity cities</a>
<a class="sourceLine" id="cb28-5" data-line-number="5">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb28-6" data-line-number="6">    go curDistance lastCity [] <span class="fu">=</span> pure (distance firstCity lastCity <span class="fu">+</span> curDistance)</a>
<a class="sourceLine" id="cb28-7" data-line-number="7">    go curDistance lastCity unvisited <span class="fu">=</span></a>
<a class="sourceLine" id="cb28-8" data-line-number="8">      <span class="kw">do</span> nextCity <span class="ot">&lt;-</span> choose unvisited</a>
<a class="sourceLine" id="cb28-9" data-line-number="9"></a>
<a class="sourceLine" id="cb28-10" data-line-number="10">         <span class="kw">let</span> unvisited' <span class="fu">=</span> filter (<span class="fu">/=</span>nextCity) unvisited</a>
<a class="sourceLine" id="cb28-11" data-line-number="11">         go (curDistance <span class="fu">+</span> distance nextCity lastCity) nextCity unvisited'</a></code></pre></div>
<p>For the problem above, we can form the set of all possible combinations.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" data-line-number="1"><span class="ot">exampleTsp ::</span> <span class="dt">Combinatorial</span> <span class="dt">Double</span></a>
<a class="sourceLine" id="cb29-2" data-line-number="2">exampleTsp <span class="fu">=</span> tspCombinatorial allCities distFunc</a></code></pre></div>
<p>Now, you may think that if we try to inspect <code>exampleTsp</code>, we’ll be in for a world of hurt. However, we can freely ask GHC for the value of <code>tsp</code> at the chosen path, without evaluating any other possible path. This is thanks to Haskell’s laziness – we can inspect partial solutions of the TSP problem without demanding the whole thing. Best of all, once we inspect the initial path, we never have to compute it again – the value of <code>tsp</code> at this path is cached, so long as we access it through <code>exampleTsp</code>.</p>
<pre class="console"><code>*Main&gt; currentSolution exampleTsp
817.0</code></pre>
<h2 id="hitting-the-metal">Hitting the metal</h2>
<p>So we now have a data structure in which to express a set of solutions along with a chosen solution and a strategy to search this set for a good enough solution. The only things we still need are one function to slightly perturb a solution and one to randomize it fully.</p>
<p>First, we’ll write a function to slightly perturb. We’ll consider a solution a slight perturbation of the current one if it chooses a different subtree at exactly <em>one</em> point in the current path. We’ll use <code>degreesOfFreedom</code> to figure out where to choose a different path. We’ll call these perturbations <em>neighbors</em> since they are “next” to the current solution.</p>
<p>We’ll use <code>RandomGen</code> from <code>System.Random</code> to abstract over our random generator.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" data-line-number="1"><span class="ot">pickNeighbor ::</span> <span class="dt">RandomGen</span> g <span class="ot">=&gt;</span> <span class="dt">Combinatorial</span> a <span class="ot">-&gt;</span> g <span class="ot">-&gt;</span> (<span class="dt">Combinatorial</span> a, g)</a>
<a class="sourceLine" id="cb31-2" data-line-number="2">pickNeighbor c g <span class="fu">=</span></a>
<a class="sourceLine" id="cb31-3" data-line-number="3">  <span class="kw">let</span> dof <span class="fu">=</span> degreesOfFreedom c</a>
<a class="sourceLine" id="cb31-4" data-line-number="4">      (forkAt, g') <span class="fu">=</span> randomR (<span class="dv">0</span>, dof <span class="fu">-</span> <span class="dv">1</span>) g</a>
<a class="sourceLine" id="cb31-5" data-line-number="5">  <span class="kw">in</span> (neighborAt forkAt c, g')</a>
<a class="sourceLine" id="cb31-6" data-line-number="6"></a>
<a class="sourceLine" id="cb31-7" data-line-number="7"><span class="ot">neighborAt ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Combinatorial</span> a <span class="ot">-&gt;</span> <span class="dt">Combinatorial</span> a</a>
<a class="sourceLine" id="cb31-8" data-line-number="8">neighborAt _ c<span class="fu">@</span>(<span class="dt">Leaf</span> {}) <span class="fu">=</span> c</a>
<a class="sourceLine" id="cb31-9" data-line-number="9">neighborAt i (<span class="dt">Choice</span> sz next rest)</a>
<a class="sourceLine" id="cb31-10" data-line-number="10">  <span class="fu">|</span> i <span class="fu">&lt;</span> sz <span class="fu">=</span> <span class="kw">let</span> next' <span class="fu">=</span> neighborAt i next</a>
<a class="sourceLine" id="cb31-11" data-line-number="11">             <span class="kw">in</span> <span class="dt">Choice</span> (degreesOfFreedom next') next' rest</a>
<a class="sourceLine" id="cb31-12" data-line-number="12">  <span class="fu">|</span> otherwise <span class="fu">=</span></a>
<a class="sourceLine" id="cb31-13" data-line-number="13">      <span class="kw">let</span> restIdx <span class="fu">=</span> i <span class="fu">-</span> sz</a>
<a class="sourceLine" id="cb31-14" data-line-number="14">          (restBefore, next'<span class="fu">:</span>restAfter) <span class="fu">=</span> splitAt restIdx rest</a>
<a class="sourceLine" id="cb31-15" data-line-number="15"></a>
<a class="sourceLine" id="cb31-16" data-line-number="16">          rest' <span class="fu">=</span> next<span class="fu">:</span>(restBefore <span class="fu">++</span> restAfter)</a>
<a class="sourceLine" id="cb31-17" data-line-number="17">      <span class="kw">in</span> <span class="dt">Choice</span> (degreesOfFreedom next') next' rest'</a></code></pre></div>
<p>Now, to randomize a given solution, we’ll just choose a random neighbor an arbitrary number of times.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" data-line-number="1"><span class="ot">randomize ::</span> <span class="dt">RandomGen</span> g <span class="ot">=&gt;</span> <span class="dt">Combinatorial</span> a <span class="ot">-&gt;</span> g <span class="ot">-&gt;</span> (<span class="dt">Combinatorial</span> a, g)</a>
<a class="sourceLine" id="cb32-2" data-line-number="2">randomize c g <span class="fu">=</span></a>
<a class="sourceLine" id="cb32-3" data-line-number="3">  <span class="kw">let</span> (numRandomizations, g') <span class="fu">=</span> randomR (<span class="dv">0</span>, degreesOfFreedom c) g</a>
<a class="sourceLine" id="cb32-4" data-line-number="4"></a>
<a class="sourceLine" id="cb32-5" data-line-number="5">      randomizeNTimes <span class="dv">0</span> c g'' <span class="fu">=</span> (c, g'')</a>
<a class="sourceLine" id="cb32-6" data-line-number="6">      randomizeNTimes n c g'' <span class="fu">=</span></a>
<a class="sourceLine" id="cb32-7" data-line-number="7">        <span class="kw">let</span> (c', g''') <span class="fu">=</span> pickNeighbor c g''</a>
<a class="sourceLine" id="cb32-8" data-line-number="8">        <span class="kw">in</span> randomizeNTimes (n <span class="fu">-</span> <span class="dv">1</span>) c' g'''</a>
<a class="sourceLine" id="cb32-9" data-line-number="9">  <span class="kw">in</span> randomizeNTimes numRandomizations c g'</a></code></pre></div>
<p>We are all set!</p>
<p>We can now define an <code>anneal</code> function that – given a <code>Combinatorial</code> and parameters for the annealing process – chooses a best guess. We’ll need to provide a random generator as well</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb33-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Temperature</span> <span class="fu">=</span> <span class="dt">Double</span></a>
<a class="sourceLine" id="cb33-2" data-line-number="2"><span class="ot">anneal ::</span> ( <span class="dt">RandomGen</span> g )</a>
<a class="sourceLine" id="cb33-3" data-line-number="3">       <span class="ot">=&gt;</span> ( energy <span class="ot">-&gt;</span> energy <span class="ot">-&gt;</span> <span class="dt">Ordering</span>)</a>
<a class="sourceLine" id="cb33-4" data-line-number="4">       <span class="ot">-&gt;</span> ( energy <span class="ot">-&gt;</span> energy <span class="ot">-&gt;</span> <span class="dt">Temperature</span> <span class="ot">-&gt;</span> <span class="dt">Double</span>) <span class="co">-- ^ Probability of accepting a worse solution</span></a>
<a class="sourceLine" id="cb33-5" data-line-number="5">       <span class="ot">-&gt;</span> <span class="dt">Temperature</span> <span class="co">-- ^ Starting temperature</span></a>
<a class="sourceLine" id="cb33-6" data-line-number="6">       <span class="ot">-&gt;</span> <span class="dt">Temperature</span> <span class="co">-- ^ Ending temperature</span></a>
<a class="sourceLine" id="cb33-7" data-line-number="7">       <span class="ot">-&gt;</span> <span class="dt">Double</span> <span class="co">-- ^ Cooling factor</span></a>
<a class="sourceLine" id="cb33-8" data-line-number="8">       <span class="ot">-&gt;</span> <span class="dt">Combinatorial</span> energy <span class="ot">-&gt;</span> g <span class="ot">-&gt;</span> (<span class="dt">Combinatorial</span> energy, g)</a>
<a class="sourceLine" id="cb33-9" data-line-number="9">anneal cmp acceptanceProbability tInitial tFinal coolingFactor initialSolution g <span class="fu">=</span></a>
<a class="sourceLine" id="cb33-10" data-line-number="10">  <span class="kw">let</span> (initial', g') <span class="fu">=</span> randomize initialSolution g</a>
<a class="sourceLine" id="cb33-11" data-line-number="11"></a>
<a class="sourceLine" id="cb33-12" data-line-number="12">      doAnneal curTemp current best curRandom</a>
<a class="sourceLine" id="cb33-13" data-line-number="13">        <span class="fu">|</span> curTemp <span class="fu">&lt;=</span> tFinal <span class="fu">=</span> (best, curRandom)</a>
<a class="sourceLine" id="cb33-14" data-line-number="14">        <span class="fu">|</span> otherwise <span class="fu">=</span></a>
<a class="sourceLine" id="cb33-15" data-line-number="15">            <span class="kw">let</span> (neighbor, curRandom') <span class="fu">=</span> pickNeighbor current curRandom</a>
<a class="sourceLine" id="cb33-16" data-line-number="16"></a>
<a class="sourceLine" id="cb33-17" data-line-number="17">                currentValue <span class="fu">=</span> currentSolution current</a>
<a class="sourceLine" id="cb33-18" data-line-number="18">                neighborValue <span class="fu">=</span> currentSolution neighbor</a>
<a class="sourceLine" id="cb33-19" data-line-number="19"></a>
<a class="sourceLine" id="cb33-20" data-line-number="20">                (diceRoll, curRandom'') <span class="fu">=</span> randomR (<span class="dv">0</span>, <span class="dv">1</span>) curRandom'</a>
<a class="sourceLine" id="cb33-21" data-line-number="21">                acceptNeighbor <span class="fu">=</span> cmp neighborValue currentValue <span class="fu">==</span> <span class="dt">LT</span> <span class="fu">||</span></a>
<a class="sourceLine" id="cb33-22" data-line-number="22">                                 acceptanceProbability currentValue neighborValue curTemp <span class="fu">&gt;</span> diceRoll</a>
<a class="sourceLine" id="cb33-23" data-line-number="23"></a>
<a class="sourceLine" id="cb33-24" data-line-number="24">                (current', current'Value) <span class="fu">=</span></a>
<a class="sourceLine" id="cb33-25" data-line-number="25">                  <span class="kw">if</span> acceptNeighbor</a>
<a class="sourceLine" id="cb33-26" data-line-number="26">                  <span class="kw">then</span> (neighbor, neighborValue)</a>
<a class="sourceLine" id="cb33-27" data-line-number="27">                  <span class="kw">else</span> (current, currentValue)</a>
<a class="sourceLine" id="cb33-28" data-line-number="28"></a>
<a class="sourceLine" id="cb33-29" data-line-number="29">                best' <span class="fu">=</span> <span class="kw">if</span> cmp current'Value (currentSolution best) <span class="fu">==</span> <span class="dt">LT</span></a>
<a class="sourceLine" id="cb33-30" data-line-number="30">                        <span class="kw">then</span> current'</a>
<a class="sourceLine" id="cb33-31" data-line-number="31">                        <span class="kw">else</span> best</a>
<a class="sourceLine" id="cb33-32" data-line-number="32">            <span class="kw">in</span> doAnneal (curTemp <span class="fu">*</span> (<span class="dv">1</span> <span class="fu">-</span> coolingFactor)) current' best' curRandom''</a>
<a class="sourceLine" id="cb33-33" data-line-number="33">  <span class="kw">in</span> doAnneal tInitial initial' initial' g'</a>
<a class="sourceLine" id="cb33-34" data-line-number="34"></a>
<a class="sourceLine" id="cb33-35" data-line-number="35"><span class="ot">defaultAcceptanceProbability ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Temperature</span> <span class="ot">-&gt;</span> <span class="dt">Double</span></a>
<a class="sourceLine" id="cb33-36" data-line-number="36">defaultAcceptanceProbability curValue neighborValue curTemp <span class="fu">=</span></a>
<a class="sourceLine" id="cb33-37" data-line-number="37">  exp (<span class="fu">-</span>(neighborValue <span class="fu">-</span> curValue)<span class="fu">/</span>(curValue <span class="fu">*</span> curTemp))</a></code></pre></div>
<p>Now we can solve our traveling salesman problem stochastically. First, a utility function to run the annealing in the <code>IO</code> monad using a new random generator.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb34-1" data-line-number="1"><span class="ot">runAnneal ::</span> <span class="dt">Temperature</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Double</span></a>
<a class="sourceLine" id="cb34-2" data-line-number="2">runAnneal tInitial <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb34-3" data-line-number="3">  g <span class="ot">&lt;-</span> newStdGen</a>
<a class="sourceLine" id="cb34-4" data-line-number="4">  <span class="kw">let</span> (result, _) <span class="fu">=</span> anneal compare defaultAcceptanceProbability tInitial <span class="dv">1</span> <span class="fl">0.003</span> exampleTsp g</a>
<a class="sourceLine" id="cb34-5" data-line-number="5">  pure (currentSolution result)</a></code></pre></div>
<p>Running it gives (results will obviously vary due to randomness):</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb35-1" data-line-number="1"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> runAnneal <span class="dv">100000</span></a>
<a class="sourceLine" id="cb35-2" data-line-number="2"><span class="fl">488.0</span></a></code></pre></div>
<p>This is certainly better than the naïve solution of visiting every city in order:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb36-1" data-line-number="1"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> head (tsp allCities distFunc)</a>
<a class="sourceLine" id="cb36-2" data-line-number="2"><span class="fl">817.0</span></a></code></pre></div>
<h2 id="asking-for-directions">Asking for directions</h2>
<p>Because <code>Combinatorial</code> is a <code>Monad</code>, we can use all the normal <code>Monad</code> tricks. For example, if we want to get the path along with the length, we can use <code>MonadWriter</code>.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb37-1" data-line-number="1"><span class="ot">tspWithPath ::</span> [ <span class="dt">City</span> ] <span class="ot">-&gt;</span> (<span class="dt">City</span> <span class="ot">-&gt;</span> <span class="dt">City</span> <span class="ot">-&gt;</span> <span class="dt">Double</span>)</a>
<a class="sourceLine" id="cb37-2" data-line-number="2">            <span class="ot">-&gt;</span> <span class="dt">WriterT</span> [<span class="dt">City</span>] <span class="dt">Combinatorial</span> <span class="dt">Double</span></a>
<a class="sourceLine" id="cb37-3" data-line-number="3">tspWithPath [] _ <span class="fu">=</span> pure <span class="dv">0</span></a>
<a class="sourceLine" id="cb37-4" data-line-number="4">tspWithPath (firstCity<span class="fu">:</span>cities) distance <span class="fu">=</span> go <span class="dv">0</span> firstCity cities</a>
<a class="sourceLine" id="cb37-5" data-line-number="5">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb37-6" data-line-number="6">    go curDistance lastCity [] <span class="fu">=</span> pure (distance firstCity lastCity <span class="fu">+</span> curDistance)</a>
<a class="sourceLine" id="cb37-7" data-line-number="7">    go curDistance lastCity unvisited <span class="fu">=</span></a>
<a class="sourceLine" id="cb37-8" data-line-number="8">      <span class="kw">do</span> nextCity <span class="ot">&lt;-</span> lift (choose unvisited)</a>
<a class="sourceLine" id="cb37-9" data-line-number="9">         tell [nextCity]</a>
<a class="sourceLine" id="cb37-10" data-line-number="10"></a>
<a class="sourceLine" id="cb37-11" data-line-number="11">         <span class="kw">let</span> unvisited' <span class="fu">=</span> filter (<span class="fu">/=</span>nextCity) unvisited</a>
<a class="sourceLine" id="cb37-12" data-line-number="12">         go (curDistance <span class="fu">+</span> distance nextCity lastCity) nextCity unvisited'</a>
<a class="sourceLine" id="cb37-13" data-line-number="13"></a>
<a class="sourceLine" id="cb37-14" data-line-number="14"><span class="ot">exampleTspWithPath ::</span> <span class="dt">Combinatorial</span> (<span class="dt">Double</span>, [<span class="dt">City</span>])</a>
<a class="sourceLine" id="cb37-15" data-line-number="15">exampleTspWithPath <span class="fu">=</span> runWriterT (tspWithPath allCities distFunc)</a>
<a class="sourceLine" id="cb37-16" data-line-number="16"></a>
<a class="sourceLine" id="cb37-17" data-line-number="17"><span class="ot">runAnnealWithPath ::</span> <span class="dt">Temperature</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Double</span>, [<span class="dt">City</span>])</a>
<a class="sourceLine" id="cb37-18" data-line-number="18">runAnnealWithPath tInitial <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb37-19" data-line-number="19">  g <span class="ot">&lt;-</span> newStdGen</a>
<a class="sourceLine" id="cb37-20" data-line-number="20">  <span class="kw">let</span> (result, _) <span class="fu">=</span> anneal (comparing fst) (defaultAcceptanceProbability <span class="ot">`on`</span> fst)</a>
<a class="sourceLine" id="cb37-21" data-line-number="21">                           tInitial <span class="dv">1</span> <span class="fl">0.003</span> exampleTspWithPath g</a>
<a class="sourceLine" id="cb37-22" data-line-number="22">  pure (currentSolution result)</a></code></pre></div>
<p>Of course, we can inspect the default solution without waiting for the universe to end</p>
<pre class="console"><code>*Main&gt; currentSolution exampleTspWithPath
(817.0,[1,2,3,4,5,6,7,8,9,10,11,12,13,14])</code></pre>
<p>Running this we get</p>
<pre class="console"><code>*Main&gt; runAnnealWithPath 100000
(465.0,[10,5,3,12,1,2,6,8,4,7,9,11,13,14])</code></pre>
<h2 id="discussion">Discussion</h2>
<p>In this article, we developed an intuition to express combinatorial optimization problems using monadic flattening. We then demonstrated two concrete monads which are of interest when solving optimization problems. We saw that choosing lists as our <code>Combinatorial</code> monad let us evaluate an optimization problem by examining every possible value of the objective function. We saw that our own custom <code>Combinatorial</code> monad allowed us to think of the set of solutions as a tree which can be searched through lazily. Finally, we used simulated annealing to search through the tree to achieve good enough optimizations of arbitrary problems.</p>
<p>Our annealing function is not limited to traveling salesman problems. We can encode any NP-complete problem where we can form an appropriate optimization metric. This is not just of theoretical significance. Database engines, for example, face the issue of join ordering for optimal query performance. Our little framework provides a way to describe these problems, and then to evaluate them fully when the search space is small or use an appropriate search method when they become intractable. This is similar to how RDBMSes like PostgreSQL optimize joins.</p>
<p>Because our tree structure comes with monadic operations, we don’t need to worry about coming up with specific representations of these problems, as libraries in other languages require. For example, the equivalent problem encoded in C using a <a href="https://www.gnu.org/software/gsl/doc/html/siman.html">standard simulated annealing library</a> takes up almost 70 lines of code. In contrast, ours (the implementation of <code>tsp</code>) took only eleven, and could likely be simplified even more.</p>
<p>There are a few problems with our solution. First of all, we haven’t proven any kind of convergence to an optimal solution. Secondly, our data structure keeps around solutions which we’ve visited, but are known to be non-optimal. We could be smarter in allowing these solutions to be garbage collected and marked as inaccessible (a form of tabu search), or change our representation entirely to avoid this. It remains to be seen if this is useful.</p>
<h2 id="future-work">Future work</h2>
<p>Our tree-like structure for representing combinations can be thought of as containing the entire set of (as-yet uncomputed) solutions. In this article, we used simulated annealing to search through this structure for an optimal solution. However, there are multiple other strategies (termed <em>meta-heuristics</em>) we could use. It’s an interesting exercise for the reader to implement other search strategies, such as genetic algorithms, particle swarm optimization, or ant colony optimization. The possibilities are as endless as the possible paths through our fifteen cities!</p>
<p>Another interesting exploration would be to figure out what kinds of problems could be encoded using monads versus applicative. Above, we saw that the traveling salesman problem (which was NP-complete) requires the monadic bind. We expressed <code>simpleOpt</code> using monadic operations, but it could easily have been written using applicative. Part of me feels like there must be some interesting differences between those problems that need only applicatives, versus those that need monads.</p>
<p>These are thoughts for another day.</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>I’ll leave proving that these are valid instances up to the reader. Hint: <code>Combinatorial</code> can be expressed as a free monad over a simple base functor<a href="#fnref1" class="footnote-back">↩</a></p></li>
</ol>
</section>
</div>

<div id="disqus_thread"></div>
<script type="text/javascript">
/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
var disqus_shortname = 'travisathougiessblog'; // required: replace example with your forum shortname

/* * * DON'T EDIT BELOW THIS LINE * * */
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

        </div>
        <!-- Google Analytics Tracking -->
        <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-55204994-1', 'auto');
        ga('send', 'pageview');

        </script>
    </body>
</html>
