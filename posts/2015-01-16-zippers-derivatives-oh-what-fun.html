<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0" />
        <title>Travis Athougies - Zippers, Derivatives -- Oh what fun!</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
        <link rel="stylesheet" type="text/css" href="../css/jquery.modal.css" />
        <link href="http://fonts.googleapis.com/css?family=Open+Sans:400,300,800,700" rel="stylesheet" type="text/css">
        <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/javascript" src="../js/jquery.min.js"></script>
        <script type"text javascript" src="../js/jquery.modal.min.js"></script>
	<script type="text/javascript" src="../js/isotope.min.js"></script>
	<script type="text/javascript" src="../js/imagesloaded.min.js"></script>
        <script type="text/javascript" src="../js/gallery.js"></script>
    </head>
    <body>
        <div id="mini-header-bar">
          <div id="show-header">
            ☰
          </div>
          <h1 id="mini-logo">
            <a href="../"><p class="travis">Travis</p><p>Athougies</p></a>
          </h1>
        </div>
        <div id="gallery-modal" class="modal" style="display: hidden">
          <a href="#" id="gallery-prev"></a>
          <a href="#" id="gallery-next"></a>
          <img id="gallery-image" src="#" />
          <div id="gallery-caption">
            <span class="gallery-figure">Figure <span id="figure-number">0</span> &mdash;</span><span id="caption-text"></span>
          </div>
        </div>
        <div id="header">
            <h1 id="logo">
                <a href="../"><p class="travis">Travis</p><p>Athougies</p></a>
            </h1>
            <div id="taglines">
              technologist
              dreamer
              builder
            </div>
            <ul id="navigation">
              <li><h2>Navigation</h2>
                <ul>
                  <li><a href="../">Home</a></li>
                  <li><a href="../about.html">About</a></li>
                  <li><a href="../projects.html">Projects</a></li>
                  <li><a href="../contact.html">Contact</a></li>
                  <li><a href="../archive.html">Archive</a></li>
                </ul></li>
              <li><h2>Tags</h2>
                <ul>
                
                  <li><a href="../tags/haskell.html">haskell (16)</a></li>
                
                  <li><a href="../tags/hydroponics.html">hydroponics (9)</a></li>
                
                  <li><a href="../tags/sustainability.html">sustainability (5)</a></li>
                
                  <li><a href="../tags/gardening.html">gardening (4)</a></li>
                
                  <li><a href="../tags/math.html">math (3)</a></li>
                
                  <li><a href="../tags/beam.html">beam (3)</a></li>
                
                  <li><a href="../tags/ai.html">ai (3)</a></li>
                
                  <li><a href="../tags/web.html">web (2)</a></li>
                
                  <li><a href="../tags/type theory.html">type theory (1)</a></li>
                
                  <li><a href="../tags/physics.html">physics (1)</a></li>
                
                  <li><a href="../tags/hakyll.html">hakyll (1)</a></li>
                
                  <li><a href="../tags/food.html">food (1)</a></li>
                
                  <li><a href="../tags/finance.html">finance (1)</a></li>
                
                  <li><a href="../tags/ethics.html">ethics (1)</a></li>
                
                  <li><a href="../tags/databases.html">databases (1)</a></li>
                
                  <li><a href="../tags/business.html">business (1)</a></li>
                
                  <li><a href="../tags/agriculture.html">agriculture (1)</a></li>
                
                  <li><a href="../tags/HoTT.html">HoTT (1)</a></li>
                </ul></li>
            </ul>
          <div id="shamelessplug">
              Site proudly generated by
              <a href="http://jaspervdj.be/hakyll">Hakyll</a> <p></p>
              This site kept updated by <a href="http://travis-ci.org">Travis CI</a> <p></p>
              <img src="https://travis-ci.org/tathougies/travis-athougies-blog.svg?branch=master" />
          </div>
        </div>

        <div id="content">
            <h1>Zippers, Derivatives -- Oh what fun!</h1>

            <div class="info">
    Posted on <span class="date">January 16, 2015</span>
    
        by <span class="author">Travis Athougies</span>
    
</div>
<div class="tags">
  in
  <ul>
    
    <li><a href="../tags/haskell.html">haskell</a></li>
    
    <li><a href="../tags/math.html">math</a></li>
    
  </ul>
</div>



<div id="post">
<p>Haskell’s datatypes are <em>algebraic</em>. That is, every type can be represented as an addition or
multiplication of other types (or any combination of sums and products of other types).</p>
<p>This means that we can use all standard algebraic operations on them. For example, taking the sum of
two types is the same as using the <code>Either</code> type since the new value can be of the first type <em>or</em> of
the second type. Similarly, taking the product is the same as using the <code>(,)</code> constructor since it
requires both data from both the left type and the right type.</p>
<p>Things get more interesting however when you apply more complicated mathematical operations to these
types. For example, as shown in
<a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.22.8611">this paper</a> and as explained on
<a href="http://chris-taylor.github.io/blog/2013/02/13/the-algebra-of-algebraic-data-types-part-iii/">this website</a>,
if you <em>differentiate</em> the algebraic representation of a data type you will get the corresponding
zipper type! That’s right, you can <em>differentiate</em> Haskell data types and get a very useful result!</p>
<p>Before you continue reading this article, make sure you have a good understanding of what zippers
are. The last chapter of <a href="http://learnyouahaskell.com/zippers">Learn You a Haskell</a> is a great
resource.</p>
<h2 id="an-example">An Example</h2>
<p>Great! We now have a general procedure for calculating the zipper of any data type. As an
example, let’s create a zipper for the following type, a “Rose tree.” Rose trees are like a binary
tree except they can have many branches.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Rose</span> a <span class="ot">=</span> <span class="dt">Rose</span> a [<span class="dt">Rose</span> a]</span></code></pre></div>
<p>First, let’s represent the structure algebraically. The product has one constructor so there will be
no sum terms. The only constructor takes two arguments, so the algebraic type will be the product of
these two types. We’ll say
\[ R(a) = a \times L(R(a)), \]
where <span class="math inline">\(L(x)\)</span> is the type of lists holding values of type <span class="math inline">\(x.\)</span></p>
<p>We can write <span class="math inline">\(L(a)\)</span> as
\[ L(a) = 1 + a \times L(a) ,\]
or, if we rearrange and solve for <span class="math inline">\(L(a),\)</span>
\[ L(a) = \frac {1}{1 - a} .\]
You may be asking: <em>How could he re-arrange terms like that? We never spoke about subtraction and
division of types!</em> Indeed, you would be right. In most semirings (the general name for mathematical
objects that act like algebraic data types), you would not be able to make such statements. However,
in the case of types, we can use both subtraction and division in our proofs, and we’re guaranteed
that, although we can’t really divide or subtract types, there is a way to make the same proof
without using these operations. For more information, see
<a href="http://arxiv.org/pdf/math/9405205v1.pdf">here</a>.</p>
<p>Now, let’s find a zipper for Rose trees!
\[ R’(a) = a (L(R(a)))’ + L(R(a)) a’ = a L’(R(a))R’(a) + L(R(a)) .\]
Now, as stated in the articles above, the zipper for a list is simply the product of two lists. That
is,
\[L’(a) = L(a)^2.\]
Therefore,
\[ R’(a) = a L(R(a))^2R’(a) + L(R(a)). \]</p>
<p>Rearranging terms,
\[ R’(a) - a L(R(a))^2R’(a) = L(R(a)). \]
\[ R’(a) (1 - a L(R(a))^2) = L(R(a)). \]
\[ R’(a) = L(R(a)) \left(\frac{1}{1 - a L(R(a))^2}\right) .\]</p>
<p>Recall that the type of lists <span class="math inline">\(L(a)\)</span>
\[L(a) = \frac{1}{1 - a} .\]
Therefore,
\[\frac{1}{1 - aL(R(a))^2} = L(aL(R(a))^2) .\]</p>
<p>Now, we can write the final derivative of <code>Rose a</code>.
\[R’(a) = L(R(a)) L(aL(R(a))^2) .\]</p>
<p>Writing this as Haskell syntax, our new type <code>DRose a</code> is the product of two lists, one of <code>Rose a</code>
and the other of <code>(a,[Rose a],[Rose a])</code>.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">DRose</span> a <span class="ot">=</span> <span class="dt">DRose</span> [<span class="dt">Rose</span> a] [(a, [<span class="dt">Rose</span> a], [<span class="dt">Rose</span> a])]</span></code></pre></div>
<h3 id="interpretating-the-result">Interpretating the result</h3>
<p>Although the differentiation procedure has given us a new type. It hasn’t told us anything about how
the new type should be interpreted. After all, what does the first <code>[Rose a]</code> represent? If we think
about it though, we can see pretty clearly that the type <code>DRose a</code> corresponds to a position in the
rose tree <code>Rose a</code>, where our children are <code>[Rose a]</code> and <code>[(a, [Rose a], [Rose a])]</code> is the list of
parent contexts, where <code>a</code> is the value of the node and <code>[Rose a], [Rose a]</code> is a list zipper into
the list of children.</p>
<h2 id="building-an-intuition">Building an intuition</h2>
<p>Can we explain easily why these rules work? Below I try to build an intuition, but I won’t be very
rigorous &amp;em; see McBride’s paper for that.</p>
<p>Let’s start with the simplest derivative. The zipper of a type with respect to itself. In this case,
there is only one possible place that a “hole” for the type could be. Therefore, the type of this
zipper is simply unit. In other words,
\[ \frac{da}{da} = 1.\]</p>
<p>Next, let’s consider the derivative of a type with respect to a different type. In this case, there
are no possible holes for the latter in the former. Therefore, the zipper is the empty datatype (the
datatype with no constructors).
\[ \frac{db}{da} = 0, \text{ where } a \neq b .\]</p>
<p>This covers our base cases. Any type can be created by composing these simple types into larger
types using type addition and multiplication. Therefore, the only rules we need to consider are
the sum rule and the product rule. As a reminder, in regular differentiation, these are
\[ \begin{align}
\frac{d}{dx}(f + g) &amp;=&amp; \frac{df}{dx} + \frac{dg}{dx} \
\frac{d}{dx} fg &amp;=&amp; f\frac{dg}{dx} + g \frac{df}{dx}
\end{align} \]</p>
<p>Let’s consider the derivative of a sum type <span class="math inline">\(x + y\)</span> with respect to <span class="math inline">\(a.\)</span> We’re looking for a
datatype that can represent all the holes where we could put a value of type <span class="math inline">\(a.\)</span> In this case, <span class="math inline">\(a\)</span>
can either go somewhere in <span class="math inline">\(x\)</span> (whose zipper is <span class="math inline">\(\frac{dx}{da}\)</span>) or somewhere in <span class="math inline">\(y\)</span> (whose zipper
is <span class="math inline">\(\frac{dy}{da}\)</span>). Thus, the zipper of the sum is the sum type of the zippers. Voila!
Differentiation rule 1 is down!</p>
<p>Finally, for a product <span class="math inline">\(xy,\)</span> <span class="math inline">\(a\)</span> can either go somewhere in <span class="math inline">\(x,\)</span> in which case, we’ll need to store
the value of <span class="math inline">\(y\)</span> (for context), or it can go somewhere in <span class="math inline">\(y\)</span>, in which case we’ll need to store
<span class="math inline">\(x.\)</span> Thus, the derivative of a product will be a sum <span class="math inline">\(X + Y,\)</span> where <span class="math inline">\(X\)</span> represents the constructors
that signal that the hole is somewhere in <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span> represents those where the hole is somewhere
in <span class="math inline">\(y.\)</span></p>
<p>Let’s figure our <span class="math inline">\(X\)</span> and <span class="math inline">\(Y.\)</span></p>
<p>If <span class="math inline">\(a\)</span> goes in <span class="math inline">\(x,\)</span> then we’ll need the zipper of <span class="math inline">\(x\)</span> to be able to represent the hole in <span class="math inline">\(x.\)</span>
Packaged along with the context <span class="math inline">\(y,\)</span> this means that we need <span class="math inline">\(X = y\frac{dx}{da}\)</span> so that we can
represent any possible hole for <span class="math inline">\(a\)</span> in <span class="math inline">\(x.\)</span></p>
<p>Conversely, if <span class="math inline">\(a\)</span> goes in <span class="math inline">\(y,\)</span> then <span class="math inline">\(Y = x \frac{dy}{da}.\)</span>
Therefore,
\[\frac{d(x + y)}{da} = x\frac{dy}{da} + y\frac{dx}{da}.\]</p>
<h2 id="conclusion">Conclusion</h2>
<p>In this post, we’ve shown that the derivative of the algebraic representation of a datatype is
simply the algebraic derivative of that datatype. Additionally, we’ve shown an example where we
differentiated the rose tree type to arrive at a rose tree zipper, which we simplified into a form
that we could understand. Finally, we developed an intuition for why the rules work the way they do,
although we leave the rigorous proofs to more rigorous blogs (and journals!).</p>
<p>In the next post, I’ll explore how we can generalize this feature so that we can generate zippers of
arbitrary types. Additionally, I’ll examine how we can create zippers with multiple “holes” all of
which can interact so that we can simulate the notion of multiple pointers to the same data structure
as in an imperative language. Did I mention all of this will be in approximately <span class="math inline">\(O(1)\)</span> time? Stay
tuned!</p>
</div>

<div id="disqus_thread"></div>
<script type="text/javascript">
/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
var disqus_shortname = 'travisathougiessblog'; // required: replace example with your forum shortname

/* * * DON'T EDIT BELOW THIS LINE * * */
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

        </div>
        <!-- Google Analytics Tracking -->
        <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-55204994-1', 'auto');
        ga('send', 'pageview');

        </script>
    </body>
</html>
