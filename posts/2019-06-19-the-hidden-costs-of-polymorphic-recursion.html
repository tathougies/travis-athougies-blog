<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0" />
        <title>Travis Athougies - Hidden costs of polymorphic recursions</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
        <link rel="stylesheet" type="text/css" href="../css/jquery.modal.css" />
        <link href="http://fonts.googleapis.com/css?family=Open+Sans:400,300,800,700" rel="stylesheet" type="text/css">
        <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/javascript" src="../js/jquery.min.js"></script>
        <script type"text javascript" src="../js/jquery.modal.min.js"></script>
	<script type="text/javascript" src="../js/isotope.min.js"></script>
	<script type="text/javascript" src="../js/imagesloaded.min.js"></script>
        <script type="text/javascript" src="../js/gallery.js"></script>
    </head>
    <body>
        <div id="mini-header-bar">
          <div id="show-header">
            ☰
          </div>
          <h1 id="mini-logo">
            <a href="../"><p class="travis">Travis</p><p>Athougies</p></a>
          </h1>
        </div>
        <div id="gallery-modal" class="modal" style="display: hidden">
          <a href="#" id="gallery-prev"></a>
          <a href="#" id="gallery-next"></a>
          <img id="gallery-image" src="#" />
          <div id="gallery-caption">
            <span class="gallery-figure">Figure <span id="figure-number">0</span> &mdash;</span><span id="caption-text"></span>
          </div>
        </div>
        <div id="header">
            <h1 id="logo">
                <a href="../"><p class="travis">Travis</p><p>Athougies</p></a>
            </h1>
            <div id="taglines">
              technologist
              dreamer
              builder
            </div>
            <ul id="navigation">
              <li><h2>Navigation</h2>
                <ul>
                  <li><a href="../">Home</a></li>
                  <li><a href="../about.html">About</a></li>
                  <li><a href="../projects.html">Projects</a></li>
                  <li><a href="../contact.html">Contact</a></li>
                  <li><a href="../archive.html">Archive</a></li>
                </ul></li>
              <li><h2>Tags</h2>
                <ul>
                
                  <li><a href="../tags/haskell.html">haskell (16)</a></li>
                
                  <li><a href="../tags/hydroponics.html">hydroponics (9)</a></li>
                
                  <li><a href="../tags/sustainability.html">sustainability (5)</a></li>
                
                  <li><a href="../tags/gardening.html">gardening (4)</a></li>
                
                  <li><a href="../tags/math.html">math (3)</a></li>
                
                  <li><a href="../tags/beam.html">beam (3)</a></li>
                
                  <li><a href="../tags/web.html">web (2)</a></li>
                
                  <li><a href="../tags/type theory.html">type theory (1)</a></li>
                
                  <li><a href="../tags/physics.html">physics (1)</a></li>
                
                  <li><a href="../tags/hakyll.html">hakyll (1)</a></li>
                
                  <li><a href="../tags/food.html">food (1)</a></li>
                
                  <li><a href="../tags/finance.html">finance (1)</a></li>
                
                  <li><a href="../tags/databases.html">databases (1)</a></li>
                
                  <li><a href="../tags/business.html">business (1)</a></li>
                
                  <li><a href="../tags/agriculture.html">agriculture (1)</a></li>
                
                  <li><a href="../tags/HoTT.html">HoTT (1)</a></li>
                </ul></li>
            </ul>
          <div id="shamelessplug">
              Site proudly generated by
              <a href="http://jaspervdj.be/hakyll">Hakyll</a> <p></p>
              This site kept updated by <a href="http://travis-ci.org">Travis CI</a> <p></p>
              <img src="https://travis-ci.org/tathougies/travis-athougies-blog.svg?branch=master" />
          </div>
        </div>

        <div id="content">
            <h1>Hidden costs of polymorphic recursions</h1>

            <div class="info">
    Posted on <span class="date">June 19, 2019</span>
    
        by <span class="author">Travis Athougies</span>
    
</div>
<div class="tags">
  in
  <ul>
    
    <li><a href="../tags/haskell.html">haskell</a></li>
    
  </ul>
</div>



<div id="post">
<p>Finger trees are a sequential, persistent data structure with very
good asymptotic bounds for common operations, such as concatenation,
adding at the beginning or end, and indexing / searching. Better yet,
they can be parameterized by measure types to form many useful data
structures, like priority queues, interval trees, key value arrays,
etc.</p>
<p>It’s no surprise that they form the basis of several performant
Haskell packages such as the popular <code>Data.Seq</code> and <code>Data.FingerTree</code>.</p>
<p>A finger tree is basically a 2-3-4 tree turned on its head. The exact
layout of a finger tree is beyond the scope of this article, but a
good overview can be found
<a href="http://www.staff.city.ac.uk/~ross/papers/FingerTree.html">here</a>. Below
is a reproduction of a diagram of a finger tree from that paper.</p>
<p>Notice how at each level of the tree, subtrees are of the same
height. Most Haskell implementations of finger trees use a technique
known as <em>polymorphic recursion</em> to provide a compile time guarantee
that all child nodes at the same level have equal height. This is a
great technique, and Haskell is one of few languages that support
this.</p>
<p>However, while using finger trees in a recent project I was working
on, I began to notice that they allocated a lot more memory than I
expected. In garbage collected languages like Haskell, the larger size
of memory, the slower the program will run. Thus, I knew I needed to
minimize memory usage, while maintaining type safety. Luckily,
GHC’s type system is expressive enough to make this change.</p>
<h1 id="the-structure">The Structure</h1>
<p>The most general finger tree structure (from the <code>fingertree</code> package)
is typically given as</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">FingerTree</span> v a</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="dt">Empty</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">Single</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">Deep</span> v (<span class="dt">Digit</span> a) (<span class="dt">FingerTree</span> v (<span class="dt">Node</span> v a)) (<span class="dt">Digit</span> a)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Digit</span> a</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="dt">One</span> a</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">Two</span> a a</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">Three</span> a a a</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="dt">Four</span> a a a a</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Node</span> v a <span class="ot">=</span> <span class="dt">Node2</span> v a a <span class="op">|</span> <span class="dt">Node3</span> v a a a</span></code></pre></div>
<p>On inspection, this seems pretty straight forward. I mean, most
Haskellers are used to recursive structures, such as the list.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> [a] <span class="ot">=</span> [] <span class="op">|</span> a <span class="op">:</span> [a]</span></code></pre></div>
<p>Notice the following subtlety with <code>FingerTree</code> though: whereas <code>[a]</code>
contains a field in the <code>(:)</code> constructor of type <code>[a]</code> (the same type
as the type we’re defining), the <code>FingerTree v a</code> structure contains a
field in the <code>Deep</code> constructor of type <code>FingerTree v (Node v a)</code>. That is to say, instead of a <code>FingerTree v a</code> <code>Deep</code> constructor
containing a finger tree holding elements of type <code>a</code>, the <code>Deep</code>
finger tree holds elements of type <code>Node v a</code>. Of course, <code>Node v a</code>
represents a tree with one level of nodes. The finger tree inside a
<code>Deep</code> constructor can of course also be another <code>Deep</code> instance, and
its sub tree will now contain elements of type <code>Node v (Node v a)</code> (a
two-level tree).</p>
<p>This matches the equal level property we desired above.</p>
<h1 id="the-problem">The problem</h1>
<p>On its own, this is fine. The issue, however, comes whenever we want
to operate on this tree. Take a look at the implementation of the
<code>traverse</code> function for <code>FingerTree</code>.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">traverse' ::</span> (<span class="dt">Measured</span> v1 a1, <span class="dt">Measured</span> v2 a2, <span class="dt">Applicative</span> f) <span class="ot">=&gt;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    (a1 <span class="ot">-&gt;</span> f a2) <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> v1 a1 <span class="ot">-&gt;</span> f (<span class="dt">FingerTree</span> v2 a2)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>traverse' <span class="ot">=</span> traverseTree</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="ot">traverseTree ::</span> (<span class="dt">Measured</span> v2 a2, <span class="dt">Applicative</span> f) <span class="ot">=&gt;</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    (a1 <span class="ot">-&gt;</span> f a2) <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> v1 a1 <span class="ot">-&gt;</span> f (<span class="dt">FingerTree</span> v2 a2)</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>traverseTree _ <span class="dt">Empty</span> <span class="ot">=</span> <span class="fu">pure</span> <span class="dt">Empty</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>traverseTree f (<span class="dt">Single</span> x) <span class="ot">=</span> <span class="dt">Single</span> <span class="op">&lt;$&gt;</span> f x</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>traverseTree f (<span class="dt">Deep</span> _ pr m sf) <span class="ot">=</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    deep <span class="op">&lt;$&gt;</span> traverseDigit f pr <span class="op">&lt;*&gt;</span> traverseTree (traverseNode f) m <span class="op">&lt;*&gt;</span> traverseDigit f sf</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="ot">traverseNode ::</span> (<span class="dt">Measured</span> v2 a2, <span class="dt">Applicative</span> f) <span class="ot">=&gt;</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    (a1 <span class="ot">-&gt;</span> f a2) <span class="ot">-&gt;</span> <span class="dt">Node</span> v1 a1 <span class="ot">-&gt;</span> f (<span class="dt">Node</span> v2 a2)</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>traverseNode f (<span class="dt">Node2</span> _ a b) <span class="ot">=</span> node2 <span class="op">&lt;$&gt;</span> f a <span class="op">&lt;*&gt;</span> f b</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>traverseNode f (<span class="dt">Node3</span> _ a b c) <span class="ot">=</span> node3 <span class="op">&lt;$&gt;</span> f a <span class="op">&lt;*&gt;</span> f b <span class="op">&lt;*&gt;</span> f c</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a><span class="ot">traverseDigit ::</span> (<span class="dt">Applicative</span> f) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> <span class="dt">Digit</span> a <span class="ot">-&gt;</span> f (<span class="dt">Digit</span> b)</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>traverseDigit f (<span class="dt">One</span> a) <span class="ot">=</span> <span class="dt">One</span> <span class="op">&lt;$&gt;</span> f a</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>traverseDigit f (<span class="dt">Two</span> a b) <span class="ot">=</span> <span class="dt">Two</span> <span class="op">&lt;$&gt;</span> f a <span class="op">&lt;*&gt;</span> f b</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>traverseDigit f (<span class="dt">Three</span> a b c) <span class="ot">=</span> <span class="dt">Three</span> <span class="op">&lt;$&gt;</span> f a <span class="op">&lt;*&gt;</span> f b <span class="op">&lt;*&gt;</span> f c</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>traverseDigit f (<span class="dt">Four</span> a b c d) <span class="ot">=</span> <span class="dt">Four</span> <span class="op">&lt;$&gt;</span> f a <span class="op">&lt;*&gt;</span> f b <span class="op">&lt;*&gt;</span> f c <span class="op">&lt;*&gt;</span> f d</span></code></pre></div>
<p>In particular, notice the following case:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>traverseTree f (<span class="dt">Deep</span> _ pr m sf) <span class="ot">=</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    deep <span class="op">&lt;$&gt;</span> traverseDigit f pr <span class="op">&lt;*&gt;</span> traverseTree (traverseNode f) m <span class="op">&lt;*&gt;</span> traverseDigit f sf</span></code></pre></div>
<p>Because <code>(Deep _ pr m sf) :: FingerTree v a</code> but <code>m :: FingerTree v (Node v a)</code>, notice how we cannot pass <code>f</code> directly to
<code>traverseTree</code>. Instead, we have to pass <code>traverseNode f</code>. This
seemingly innocuous line incurs an additional heap allocation (8 bytes
or more on a 64-bit architecture) with each level of the
tree.</p>
<p>Okay, so what you ask? All we’re doing here is incurring an <code>O(log n)</code>
memory overhead when doing a traversal. That’s not that big a deal in
a language like Haskell.</p>
<p>But wait, there’s more…</p>
<p>The <code>traverseNode</code> function takes two arguments, but, when passed to
<code>traverseTree</code> it is only supplied one. That’s fine by Haskell of
course. On the implementation level however, most Haskell
implementations only perform a reduction (a function call) when a
function is fully applied. Oftentimes, the compiler can cleverly
inline or reason its way out of having to examine application arity at
compile-time. Unfortunately, in the general case, this can’t be done,
and – as a rule of thumb – GHC mainly gives up on inlining
optimizations when it comes down to recursive calls, like the one above.</p>
<p>This means that the incomplete application is stored on the heap as a
partial application (or PAP node in GHC’s STG parlance).</p>
<p>But wait, there’s more! Notice the <code>Measured</code> constraint on these
function calls. If GHC sees we have a <code>Measured v a</code> and needs to
construct a <code>Measured v (Node v a)</code> it’s actually going to construct
yet another PAP node behind the scenes to handle the <code>measure</code>
function. This happens whether we like it or not, simply due to the
fact that <code>Measured</code> is listed as a constraint, and the <code>mesaure</code>
function is used (in this case by the call to <code>deep</code>).</p>
<p>So, aside from the O(log n) memory overhead, we also have a much more
involved arity check plus indirect function application. Ugh… this
is going to be really difficult to optimize.</p>
<h1 id="indexing-to-the-rescue">Indexing to the rescue</h1>
<p>One key insight here is that the ‘shape’ of the nested types forces us
to perform these kinds of time-consuming allocations and function
calls. While technically correct, the code is not written in such a
way that the compiler can easily optimize, simply because modern
computer architectures are not really intended for this sort of highly
functional code.</p>
<p>On the other hand, GHC is great at optimizing tight loops. Nominally
of course, traverse should just be a tight loop, but, again, the
structure of the algebraic data type is getting in the way. Can we do
better?</p>
<p>One obvious solution is to simply get rid of the polymorphic
recursion. This has the advantage that we can now simply pass <code>f</code> to
each recursive call to <code>traverseTree</code> preventing the naughty
allocation.</p>
<p>However, for the type-minded in the audience, this solution doesn’t
sit well. The point of the recursion was to limit the kinds of data
structures that are members of this type to only the finger tree
structures that are balanced. Free, unbounded recursion of the fingers
would lose that guarantee.</p>
<h1 id="an-alternative">An alternative</h1>
<p>What about, instead of explicit polymorphic recursion, we instead
parameterized each <code>FingerTree</code> by its depth in the top-level finger
tree. If we had the depth available to us, then we would know how many
levels the fingers must have.</p>
<p>First, our level type, a simple type-level natural number</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DataKinds #-}</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeFamilies #-}</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Level</span> <span class="ot">=</span> <span class="dt">LZ</span> <span class="op">|</span> <span class="dt">LSucc</span> <span class="dt">Level</span></span></code></pre></div>
<p>Now, a finger tree, paramaterized by level</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">FingerTreeN</span> (<span class="ot">l ::</span> <span class="dt">Level</span>) v a <span class="kw">where</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>   <span class="dt">Empty</span><span class="ot"> ::</span> <span class="dt">FingerTreeN</span> l v a</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>   <span class="dt">Single</span><span class="ot"> ::</span> <span class="dt">Tree</span> l v a <span class="ot">-&gt;</span> <span class="dt">FingerTreeN</span> l v a</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>   <span class="dt">Deep</span><span class="ot"> ::</span> v <span class="ot">-&gt;</span> <span class="dt">Digit</span> l v a <span class="ot">-&gt;</span> <span class="dt">FingerTreeN</span> (<span class="dt">'LSucc</span> l) v a <span class="ot">-&gt;</span> <span class="dt">Digit</span> l v a <span class="ot">-&gt;</span> <span class="dt">FingerTreeN</span> l v a</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Digit</span> (<span class="ot">n ::</span> <span class="dt">Level</span>) v a</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">One</span>   (<span class="dt">Tree</span> n v a)</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Two</span>   (<span class="dt">Tree</span> n v a) (<span class="dt">Tree</span> n v a)</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Three</span> (<span class="dt">Tree</span> n v a) (<span class="dt">Tree</span> n v a) (<span class="dt">Tree</span> n v a)</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Four</span>  (<span class="dt">Tree</span> n v a) (<span class="dt">Tree</span> n v a) (<span class="dt">Tree</span> n v a) (<span class="dt">Tree</span> n v a)</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Node</span> n v a</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Node2</span> <span class="op">!</span>v <span class="op">!</span>(<span class="dt">Tree</span> n v a) <span class="op">!</span>(<span class="dt">Tree</span> n v a)</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Node3</span> <span class="op">!</span>v <span class="op">!</span>(<span class="dt">Tree</span> n v a) <span class="op">!</span>(<span class="dt">Tree</span> n v a) <span class="op">!</span>(<span class="dt">Tree</span> n v a)</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Tree</span> n v a <span class="ot">=</span> <span class="dt">Tree</span> (<span class="dt">TreeF</span> n v a)</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">TreeF</span> (<span class="ot">n ::</span> <span class="dt">Level</span>) v a <span class="kw">where</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>  <span class="dt">TreeF</span> <span class="dt">LZ</span> v a <span class="ot">=</span> a</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>  <span class="dt">TreeF</span> (<span class="dt">LSucc</span> l) v a <span class="ot">=</span> <span class="dt">Node</span> l v a</span></code></pre></div>
<p>Notice now that the recursive embedding of <code>FingerTreeN</code> is still
applied at <code>a</code>. All the polymorphism has been ‘lifted’ into the
type-level successor index of the <code>FingerTreeN</code> data family.</p>
<p>Now all we need to note is that the top-level <code>FingerTree</code> is a
<code>FingerTreeN</code> applied at level <code>LZ</code>.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">FingerTree</span> v a <span class="ot">=</span> <span class="dt">FingerTree</span> (<span class="dt">FingerTreeN</span> <span class="dt">'LZ</span> v a)</span></code></pre></div>
<p>Interestingly enough, pretty much all the implementation can stay the
same, with one caveat.</p>
<p>The <code>Level</code> parameter to the type has to be reified at the value level
in order to be of use. This means that we need to pass an extra
element to our functions to have them be of any use. We define a new
singleton for our <code>Level</code> type.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">RuntimeDepth</span> (<span class="ot">l ::</span> <span class="dt">Level</span>) <span class="kw">where</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">RuntimeZ</span><span class="ot"> ::</span> <span class="dt">RuntimeDepth</span> <span class="dt">'LZ</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">RuntimeSucc</span><span class="ot"> ::</span> <span class="dt">RuntimeDepth</span> l <span class="ot">-&gt;</span> <span class="dt">RuntimeDepth</span> (<span class="dt">'LSucc</span> l)</span></code></pre></div>
<p>Ignore the various fields on the constructors for now.</p>
<p>Now, we can pattern match on <code>RuntimeDepth</code> to prove to the compiler
if <code>TreeF n v a</code> is <code>a</code> or an application of <code>Node</code>.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">traverse' ::</span> (<span class="dt">Measured</span> v1 a1, <span class="dt">Measured</span> v2 a2, <span class="dt">Applicative</span> f)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>          <span class="ot">=&gt;</span> (a1 <span class="ot">-&gt;</span> f a2) <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> v1 a1 <span class="ot">-&gt;</span> f (<span class="dt">FingerTree</span> v2 a2)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>traverse' f (<span class="dt">FingerTree</span> t) <span class="ot">=</span> <span class="dt">FingerTree</span> <span class="op">&lt;$&gt;</span> traverse'' zeroDepth f t</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="ot">traverse'' ::</span> (<span class="dt">Measured</span> v1 a1, <span class="dt">Measured</span> v2 a2, <span class="dt">Applicative</span> f)</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>           <span class="ot">=&gt;</span> <span class="dt">RuntimeDepth</span> l <span class="ot">-&gt;</span> (a1 <span class="ot">-&gt;</span> f a2) <span class="ot">-&gt;</span> <span class="dt">FingerTreeN</span> l v1 a1 <span class="ot">-&gt;</span> f (<span class="dt">FingerTreeN</span> l v2 a2)</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>traverse'' <span class="op">!</span>_ _ <span class="dt">Empty</span> <span class="ot">=</span> <span class="fu">pure</span> <span class="dt">Empty</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>traverse'' <span class="op">!</span>l f (<span class="dt">Single</span> x) <span class="ot">=</span> <span class="dt">Single</span> <span class="op">&lt;$&gt;</span> traverseTree l f x</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>traverse'' <span class="op">!</span>l f (<span class="dt">Deep</span> _ pr m sf) <span class="ot">=</span> deep l <span class="op">&lt;$&gt;</span> traverseDigit l f pr <span class="op">&lt;*&gt;</span> traverse'' (nextDepth l) f m <span class="op">&lt;*&gt;</span> traverseDigit l f sf</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a><span class="ot">traverseTree ::</span> (<span class="dt">Measured</span> v1 a1, <span class="dt">Measured</span> v2 a2, <span class="dt">Applicative</span> f)</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>             <span class="ot">=&gt;</span> <span class="dt">RuntimeDepth</span> l <span class="ot">-&gt;</span> (a1 <span class="ot">-&gt;</span> f a2) <span class="ot">-&gt;</span> <span class="dt">Tree</span> l v1 a1 <span class="ot">-&gt;</span> f (<span class="dt">Tree</span> l v2 a2)</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>traverseTree (<span class="dt">RuntimeZ</span> _) f (<span class="dt">Tree</span> x) <span class="ot">=</span> <span class="dt">Tree</span> <span class="op">&lt;$&gt;</span> f x</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>traverseTree (<span class="dt">RuntimeSucc</span> l') f (<span class="dt">Tree</span> (<span class="dt">Node2</span> _ a b)) <span class="ot">=</span> treeDigit <span class="op">&lt;$&gt;</span> (node2 l' <span class="op">&lt;$&gt;</span> traverseTree l' f a <span class="op">&lt;*&gt;</span> traverseTree l' f b)</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>traverseTree (<span class="dt">RuntimeSucc</span> l') f (<span class="dt">Tree</span> (<span class="dt">Node3</span> _ a b c)) <span class="ot">=</span> treeDigit <span class="op">&lt;$&gt;</span> (node3 l' <span class="op">&lt;$&gt;</span> traverseTree l' f a <span class="op">&lt;*&gt;</span> traverseTree l' f b <span class="op">&lt;*&gt;</span> traverseTree l' f c)</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a><span class="ot">traverseDigit ::</span> (<span class="dt">Measured</span> v1 a1, <span class="dt">Measured</span> v2 a2, <span class="dt">Applicative</span> f)</span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>              <span class="ot">=&gt;</span> <span class="dt">RuntimeDepth</span> l <span class="ot">-&gt;</span> (a1 <span class="ot">-&gt;</span> f a2) <span class="ot">-&gt;</span> <span class="dt">Digit</span> l v1 a1 <span class="ot">-&gt;</span> f (<span class="dt">Digit</span> l v2 a2)</span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>traverseDigit <span class="op">!</span>l f (<span class="dt">One</span> a) <span class="ot">=</span> <span class="dt">One</span> <span class="op">&lt;$&gt;</span> traverseTree l f a</span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>traverseDigit <span class="op">!</span>l f (<span class="dt">Two</span> a b) <span class="ot">=</span> <span class="dt">Two</span> <span class="op">&lt;$&gt;</span> traverseTree l f a <span class="op">&lt;*&gt;</span> traverseTree l f b</span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>traverseDigit <span class="op">!</span>l f (<span class="dt">Three</span> a b c) <span class="ot">=</span> <span class="dt">Three</span> <span class="op">&lt;$&gt;</span> traverseTree l f a <span class="op">&lt;*&gt;</span> traverseTree l f b <span class="op">&lt;*&gt;</span> traverseTree l f c</span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>traverseDigit <span class="op">!</span>l f (<span class="dt">Four</span> a b c d) <span class="ot">=</span> <span class="dt">Four</span> <span class="op">&lt;$&gt;</span> traverseTree l f a <span class="op">&lt;*&gt;</span> traverseTree l f b <span class="op">&lt;*&gt;</span> traverseTree l f c <span class="op">&lt;*&gt;</span> traverseTree l f d</span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a><span class="ot">nextDepth ::</span> <span class="dt">RuntimeDepth</span> l <span class="ot">-&gt;</span> <span class="dt">RuntimeDepth</span> (<span class="dt">'LSucc</span> l)</span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a>nextDepth <span class="ot">=</span> <span class="dt">RuntimeSucc</span></span></code></pre></div>
<p>Of course, if we had to continuously construct new <code>RuntimeDepth</code>s
using <code>nextDepth</code>, we’re still allocating things on the heap. Luckily,
we can get rid of this too, by adding a pointer to each <code>RuntimeDepth</code>
constructor to the next one in the series.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">RuntimeDepth</span> (<span class="ot">l ::</span> <span class="dt">Level</span>) <span class="kw">where</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">RuntimeZ</span><span class="ot"> ::</span> <span class="dt">RuntimeDepth</span> (<span class="dt">'LSucc</span> <span class="dt">'LZ</span>) <span class="ot">-&gt;</span> <span class="dt">RuntimeDepth</span> <span class="dt">'LZ</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">RuntimeSucc</span><span class="ot"> ::</span> <span class="dt">RuntimeDepth</span> (<span class="dt">'LSucc</span> (<span class="dt">'LSucc</span> l)) <span class="ot">-&gt;</span> <span class="dt">RuntimeDepth</span> l <span class="ot">-&gt;</span> <span class="dt">RuntimeDepth</span> (<span class="dt">'LSucc</span> l)</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="ot">zeroDepth ::</span> <span class="dt">RuntimeDepth</span> <span class="dt">'LZ</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>zeroDepth <span class="ot">=</span> <span class="kw">let</span> x <span class="ot">=</span> <span class="dt">RuntimeZ</span> (next x)</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>                next prev <span class="ot">=</span> <span class="kw">let</span> y <span class="ot">=</span> <span class="dt">RuntimeSucc</span> prev (next y)</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>                            <span class="kw">in</span> y</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>            <span class="kw">in</span> x</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a><span class="ot">nextDepth ::</span> <span class="dt">RuntimeDepth</span> l <span class="ot">-&gt;</span> <span class="dt">RuntimeDepth</span> (<span class="dt">'LSucc</span> l)</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>nextDepth (<span class="dt">RuntimeZ</span> x) <span class="ot">=</span> x</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>nextDepth (<span class="dt">RuntimeSucc</span> x _) <span class="ot">=</span> x</span></code></pre></div>
<p>Now, due to the power of laziness, these are only ever allocated once
per run of the program. Once allocated, the nodes are reused. We now
have allocation free recursion for <code>traverse</code>!</p>
<p>Let’s see if this stands to scrutiny.</p>
<h1 id="benchmarking">Benchmarking</h1>
<p>My version of finger trees (with code broadly copied from the
<code>fingertree</code> package) is available on
<a href="https://hackage.haskell.org/pinky">Hackage</a>. I’ve named these
structures ‘pinky trees’ because they’re like finger trees, but
lighter weight.</p>
<p>I’m going to use the benchmarks from the haskell-perf <code>sequences</code>
<a href="https://github.com/haskell-perf/sequences">repository</a>. We’re going
to look at total runtime as well as memory usage.</p>
<p>I’m going to compare my trees against the generic <code>fingertree</code> package
to make a fair comparison (<code>Data.Sequence</code> explicitly fixes the <code>v</code>
above allowing the compiler to make some heap representation
optimizations not available in the general case).</p>
<p>My benchmarks are available <a href="http://github.com/tathougies/pinky-tree-bench">here</a>.</p>
<p>As you can see, pinky trees are superior in all respects to finger trees.</p>
<h1 id="next-steps">Next steps</h1>
<p>The <code>Data.FingerTree.Pinky</code> package is a pretty much drop-in
replacement for <code>Data.FingerTree</code>. There are a few missing functions,
but they should be easily added by copy-pasting (a technique I rarely
recommend).</p>
<p>Happy finger tree-ing!</p>
</div>

<div id="disqus_thread"></div>
<script type="text/javascript">
/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
var disqus_shortname = 'travisathougiessblog'; // required: replace example with your forum shortname

/* * * DON'T EDIT BELOW THIS LINE * * */
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

        </div>
        <!-- Google Analytics Tracking -->
        <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-55204994-1', 'auto');
        ga('send', 'pageview');

        </script>
    </body>
</html>
