<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0" />
        <title>Travis Athougies - Beam tutorial (part 2)</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
        <link rel="stylesheet" type="text/css" href="../css/jquery.modal.css" />
        <link href="http://fonts.googleapis.com/css?family=Open+Sans:400,300,800,700" rel="stylesheet" type="text/css">
        <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/javascript" src="../js/jquery.min.js"></script>
        <script type"text javascript" src="../js/jquery.modal.min.js"></script>
	<script type="text/javascript" src="../js/isotope.min.js"></script>
	<script type="text/javascript" src="../js/imagesloaded.min.js"></script>
        <script type="text/javascript" src="../js/gallery.js"></script>
    </head>
    <body>
        <div id="mini-header-bar">
          <div id="show-header">
            ☰
          </div>
          <h1 id="mini-logo">
            <a href="../"><p class="travis">Travis</p><p>Athougies</p></a>
          </h1>
        </div>
        <div id="gallery-modal" class="modal" style="display: hidden">
          <a href="#" id="gallery-prev"></a>
          <a href="#" id="gallery-next"></a>
          <img id="gallery-image" src="#" />
          <div id="gallery-caption">
            <span class="gallery-figure">Figure <span id="figure-number">0</span> &mdash;</span><span id="caption-text"></span>
          </div>
        </div>
        <div id="header">
            <h1 id="logo">
                <a href="../"><p class="travis">Travis</p><p>Athougies</p></a>
            </h1>
            <div id="taglines">
              technologist
              dreamer
              builder
            </div>
            <ul id="navigation">
              <li><h2>Navigation</h2>
                <ul>
                  <li><a href="../">Home</a></li>
                  <li><a href="../about.html">About</a></li>
                  <li><a href="../projects.html">Projects</a></li>
                  <li><a href="../contact.html">Contact</a></li>
                  <li><a href="../archive.html">Archive</a></li>
                </ul></li>
              <li><h2>Tags</h2>
                <ul>
                
                  <li><a href="../tags/haskell.html">haskell (16)</a></li>
                
                  <li><a href="../tags/hydroponics.html">hydroponics (9)</a></li>
                
                  <li><a href="../tags/sustainability.html">sustainability (5)</a></li>
                
                  <li><a href="../tags/gardening.html">gardening (4)</a></li>
                
                  <li><a href="../tags/math.html">math (3)</a></li>
                
                  <li><a href="../tags/beam.html">beam (3)</a></li>
                
                  <li><a href="../tags/ai.html">ai (3)</a></li>
                
                  <li><a href="../tags/web.html">web (2)</a></li>
                
                  <li><a href="../tags/type theory.html">type theory (1)</a></li>
                
                  <li><a href="../tags/physics.html">physics (1)</a></li>
                
                  <li><a href="../tags/hakyll.html">hakyll (1)</a></li>
                
                  <li><a href="../tags/food.html">food (1)</a></li>
                
                  <li><a href="../tags/finance.html">finance (1)</a></li>
                
                  <li><a href="../tags/ethics.html">ethics (1)</a></li>
                
                  <li><a href="../tags/databases.html">databases (1)</a></li>
                
                  <li><a href="../tags/business.html">business (1)</a></li>
                
                  <li><a href="../tags/agriculture.html">agriculture (1)</a></li>
                
                  <li><a href="../tags/HoTT.html">HoTT (1)</a></li>
                </ul></li>
            </ul>
          <div id="shamelessplug">
              Site proudly generated by
              <a href="http://jaspervdj.be/hakyll">Hakyll</a> <p></p>
              This site kept updated by <a href="http://travis-ci.org">Travis CI</a> <p></p>
              <img src="https://travis-ci.org/tathougies/travis-athougies-blog.svg?branch=master" />
          </div>
        </div>

        <div id="content">
            <h1>Beam tutorial (part 2)</h1>

            <div class="info">
    Posted on <span class="date">January 22, 2016</span>
    
        by <span class="author">Travis Athougies</span>
    
</div>
<div class="tags">
  in
  <ul>
    
    <li><a href="../tags/haskell.html">haskell</a></li>
    
    <li><a href="../tags/beam.html">beam</a></li>
    
  </ul>
</div>



<div id="post">
<p>This is the second part in my tutorial on the beam database library. This
tutorial assumes you’ve read through the <a href="../posts/2016-01-21-beam-tutorial-1.html">first
tutorial</a> already. A literate haskell version
of this exact tutorial can be found on
<a href="https://github.com/tathougies/beam/blob/master/Doc/02-NextSteps.lhs">GitHub</a>.</p>
<p>Author’s note: This has been superseded by the <a href="https://tathougies.github.io/beam">Beam manual</a>.</p>
<h2 id="introduction">Introduction</h2>
<p>In the previous tutorial, we created a simple database with one table. We then used
the beam interface to add entities into that table and query them. In this tutorial, we’ll see how
to update and delete rows and how to establish and query relations between tables.</p>
<p>We’ll then delve deeper into queries to see how to create queries that return multiple tables</p>
<h2 id="where-we-left-off">Where we left off</h2>
<p>When we last left off, we had a database with one table, <code>UserT</code>. We duplicate all the work up until
this point from the last tutorial here.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE StandaloneDeriving, TypeSynonymInstances, FlexibleInstances, TypeFamilies, DeriveGeneric, OverloadedStrings #-}</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Database.Beam</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Database.Beam.Backend.Sqlite3</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Text</span> (<span class="dt">Text</span>)</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Lens.Micro</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">UserT</span> f <span class="ot">=</span> <span class="dt">User</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>             {<span class="ot"> _userEmail     ::</span> <span class="dt">Columnar</span> f <span class="dt">Text</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>             ,<span class="ot"> _userFirstName ::</span> <span class="dt">Columnar</span> f <span class="dt">Text</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>             ,<span class="ot"> _userLastName  ::</span> <span class="dt">Columnar</span> f <span class="dt">Text</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>             ,<span class="ot"> _userPassword  ::</span> <span class="dt">Columnar</span> f <span class="dt">Text</span> }</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>              <span class="kw">deriving</span> <span class="dt">Generic</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">User</span> <span class="ot">=</span> <span class="dt">UserT</span> <span class="dt">Identity</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">User</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Table</span> <span class="dt">UserT</span> <span class="kw">where</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">data</span> <span class="dt">PrimaryKey</span> <span class="dt">UserT</span> f <span class="ot">=</span> <span class="dt">UserId</span> (<span class="dt">Columnar</span> f <span class="dt">Text</span>) <span class="kw">deriving</span> <span class="dt">Generic</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>    primaryKey <span class="ot">=</span> <span class="dt">UserId</span> <span class="op">.</span> _userEmail</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">UserId</span> <span class="ot">=</span> <span class="dt">PrimaryKey</span> <span class="dt">UserT</span> <span class="dt">Identity</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a><span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">UserId</span></span></code></pre></div>
<h2 id="adding-a-related-table">Adding a related table</h2>
<p>The users in our simple e-commerce application would like to ship orders to their homes. Let’s build
an addresses model to allow users to add home addresses to their profile. Our table will store
United States addresses for now. An address in the United States consists of</p>
<ul>
<li>one required house number and street line</li>
<li>an optional apartment/suite number line</li>
<li>a required city</li>
<li>a required 2-letter state/territory code</li>
<li>one 5-digit ZIP code</li>
</ul>
<p>Let’s build the <code>AddressT</code> table. <code>AddressT</code> will follow a similar formula to <code>UserT</code>, but it will
contain a reference to a <code>UserT</code> table.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">AddressT</span> f <span class="ot">=</span> <span class="dt">Address</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>                {<span class="ot"> _addressId    ::</span> <span class="dt">Columnar</span> f <span class="dt">AutoId</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>                ,<span class="ot"> _addressLine1 ::</span> <span class="dt">Columnar</span> f <span class="dt">Text</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>                ,<span class="ot"> _addressLine2 ::</span> <span class="dt">Columnar</span> f (<span class="dt">Maybe</span> <span class="dt">Text</span>)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>                ,<span class="ot"> _addressCity  ::</span> <span class="dt">Columnar</span> f <span class="dt">Text</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>                ,<span class="ot"> _addressState ::</span> <span class="dt">Columnar</span> f <span class="dt">Text</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>                ,<span class="ot"> _addressZip   ::</span> <span class="dt">Columnar</span> f <span class="dt">Text</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>                ,<span class="ot"> _addressForUser ::</span> <span class="dt">PrimaryKey</span> <span class="dt">UserT</span> f }</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">deriving</span> <span class="dt">Generic</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Address</span> <span class="ot">=</span> <span class="dt">AddressT</span> <span class="dt">Identity</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Address</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Table</span> <span class="dt">AddressT</span> <span class="kw">where</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">data</span> <span class="dt">PrimaryKey</span> <span class="dt">AddressT</span> f <span class="ot">=</span> <span class="dt">AddressId</span> (<span class="dt">Columnar</span> f <span class="dt">AutoId</span>) <span class="kw">deriving</span> <span class="dt">Generic</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>    primaryKey <span class="ot">=</span> <span class="dt">AddressId</span> <span class="op">.</span> _addressId</span></code></pre></div>
<p>The lines of particular interest are the declarations for <code>_addressId</code> and <code>_addressForUser</code>.</p>
<p>The <code>_addressId</code> field is declared with type <code>AutoId</code>. <code>AutoId</code> is defined in <code>Database.Beam.Schema.Fields</code> as</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">AutoId</span> <span class="ot">=</span> <span class="dt">UnassignedId</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="dt">AssignedId</span> <span class="op">!</span><span class="dt">Int</span></span></code></pre></div>
<p>When created in the database, <code>AutoId</code> defaults to a field that will automatically assign itself a
unique number when a NULL is written to it. Many people use such a field to create an easy primary
key. Note that depending on your backend, such a field may only be possible if it is also declared
as the primary key, which it is in our example.</p>
<p>The second field of interest is <code>_addressForUser</code>, which is declared as a <code>PrimaryKey UserT f</code>. This
pulls in all the columns necessary for referencing a <code>UserT</code>. Later, we’ll also see how beam can use
the field to automatically create JOINs.</p>
<h3 id="specifiying-field-options">Specifiying Field Options</h3>
<p>Above, we gave two requirements for the state and ZIP code fields. We said that state must be a
2-digit state/territory code and ZIP must be at most 4 digits. This means we’d want to declare the
state field as a <code>CHAR(2)</code> in SQL, and the ZIP a <code>VARCHAR(5)</code>. By default, <code>Text</code> fields are
declared <code>VARCHAR</code>. As you may have guessed, beam provides a mechanism for changing the default.</p>
<p>We can declare options for a beam table by overriding the <code>tblFieldSettings</code> value in <code>Table</code>. This
value defaults to <code>defTblFieldSettings</code> and is constructed from the generic representation of the
table. If we use GHCi, we see that the type of <code>tblFieldSettings</code> is <code>DatabaseSettings table</code>. <code>DatabaseSettings table</code> is a type synonym for <code>table (TableField table)</code>. <code>TableField table</code> is another column tag (similar to <code>Identity</code>) that lets us define options on each table
field. By default, each table field of type <code>Columnar (TableField table) x</code> will now hold a value of
type <code>TableField table x</code>.</p>
<p>Because <code>TableField</code>s are deeply nested structures, it’s easiest to use lenses to modify them. Beam
does not depend on the <code>lens</code> library, but lenses are plain old polymorphic Haskell data types, so
we can still make use of them without that library. In this example, we pulled in the
<code>microlens</code> library, which contains many common <code>lens</code> functions, but which does not use Template
Haskell. <code>microlens</code> is 100% compatible with <code>lens</code>, and beam is agnostic when it comes to choice of lens library.</p>
<p>Nevertheless, without Template Haskell we are typically left without any easy way to derive
lenses. Luckily for us, we’ll see how beam let’s us automatically derive these lenses. For now,
let’s just assume the following lenses exist:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">addressStateC ::</span> <span class="dt">Lens'</span> (<span class="dt">AddressT</span> (<span class="dt">TableField</span> <span class="dt">AddressT</span>)) (<span class="dt">TableField</span> <span class="dt">AddressT</span> <span class="dt">Text</span>)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="ot">addressZipC ::</span> <span class="dt">Lens'</span> (<span class="dt">AddressT</span> (<span class="dt">TableField</span> <span class="dt">AddressT</span>)) (<span class="dt">TableField</span> <span class="dt">AddressT</span> <span class="dt">Text</span>)</span></code></pre></div>
<p>We also have the following lenses of interest to interface with <code>TableField table</code>:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">fieldName ::</span> <span class="dt">Lens'</span> (<span class="dt">TableField</span> table ty) <span class="dt">Text</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="ot">fieldSchema ::</span> <span class="dt">Lens</span> (<span class="dt">TableField</span> table a) (<span class="dt">TableField</span> table b) (<span class="dt">FieldSchema</span> a) (<span class="dt">FieldSchema</span> b)</span></code></pre></div>
<p>A <code>FieldSchema a</code> is a record type that contains information on how to
serialize and deserialize the particular column. Beam automatically
chooses a default field schema for you using the
<code>HasDefaultFieldSchema</code> type class.</p>
<p>For our purposes, we need only look at the <code>textSchema</code> column schema
constructor. It takes in a sum type <code>CharOrVarchar</code> and produces the
appropriate schema for a <code>Text</code> field.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">textSchema ::</span> <span class="dt">CharOrVarchar</span> <span class="ot">-&gt;</span> <span class="dt">FieldSchema</span> <span class="dt">Text</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">CharOrVarchar</span> <span class="ot">=</span> <span class="dt">Char</span> (<span class="dt">Maybe</span> <span class="dt">Int</span>)</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>                   <span class="op">|</span> <span class="dt">Varchar</span> (<span class="dt">Maybe</span> <span class="dt">Int</span>)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>                     <span class="kw">deriving</span> <span class="dt">Show</span></span></code></pre></div>
<p>Let’s use these lenses and this knowledge to modify the default storage type for these two
fields. We’re going to override the <code>tblFieldSettings</code> value in the <code>Table AddressT</code>
instantiation. We can use <code>defTblFieldSettings</code> to get the automatically derived settings from Beam,
so that we can only override the parts we’re interested in.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>    tblFieldSettings <span class="ot">=</span> defTblFieldSettings</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>                       <span class="op">&amp;</span> addressStateC <span class="op">.</span> fieldSchema <span class="op">.~</span> textSchema (<span class="dt">Char</span> (<span class="dt">Just</span> <span class="dv">2</span>))</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>                       <span class="op">&amp;</span> addressZipC <span class="op">.</span> fieldSchema <span class="op">.~</span> textSchema (<span class="dt">Varchar</span> (<span class="dt">Just</span> <span class="dv">5</span>))</span></code></pre></div>
<p>This completes our <code>Table AddressT</code> instantiation.</p>
<h3 id="lenses-for-free">Lenses for free</h3>
<p>Above we presumed the existence of lenses that let us access the <code>Columnar (TableField Address) x</code>
members of our table type. Here, we’ll see how we can make these lenses using generics. First we
start with the finish product, and then explain what’s going on.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Address</span> (<span class="dt">LensFor</span> addressIdC)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>        (<span class="dt">LensFor</span> addressLine1C)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>        (<span class="dt">LensFor</span> addressLine2C)</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>        (<span class="dt">LensFor</span> addressCityC)</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>        (<span class="dt">LensFor</span> addressStateC)</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>        (<span class="dt">LensFor</span> addressZipC)</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>        (<span class="dt">UserId</span> (<span class="dt">LensFor</span> addressForUserIdC)) <span class="ot">=</span> tableConfigLenses</span></code></pre></div>
<p>This is a pattern match at the top level. <code>tableConfigLenses</code> uses GHC’s generics mechanism and a
special column tag to automatically replace all instances of <code>Columnar f x</code> in the data structure
with the <code>LensFor</code> newtype. Note how it even replaced the <code>Colunmar f x</code>s that were embedded in the
<code>_addressForUser</code> primary key field.</p>
<p>We can ask GHC for the types of the derived lenses. As a reminder, the type of a simple van
Laarhoven lens from a data structure <code>a</code> to a substructure <code>b</code> is</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Lens'</span> <span class="ot">=</span> <span class="kw">forall</span> f<span class="op">.</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (b <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> f a</span></code></pre></div>
<p>We’d expect that the type of <code>addressZipC</code> is</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ot">addressZipC ::</span> <span class="dt">Lens'</span> (<span class="dt">AddressT</span> (<span class="dt">TableField</span> <span class="dt">AddressT</span>)) (<span class="dt">TableField</span> <span class="dt">AddressT</span> <span class="dt">Text</span>)</span></code></pre></div>
<p>If we ask GHCi, we get</p>
<pre><code>*NextSteps&gt; :t addressZipC
addressZipC
:: Functor f =&gt;
   (TableField AddressT Text -&gt; f (TableField AddressT Text))
   -&gt; AddressT (TableField AddressT)
   -&gt; f (AddressT (TableField AddressT))</code></pre>
<p>which is equivalent to the above.</p>
<h2 id="working-with-relations">Working with relations</h2>
<p>Now, let’s see how we can add related addresses to our database. First, we’ll define a type for our
new database and declare an instance of the database, using the default beam settings. We’ll then
open up a connection for us to use in the rest of the tutorial.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ShoppingCartDb</span> f <span class="ot">=</span> <span class="dt">ShoppingCartDb</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>                      {<span class="ot"> _shoppingCartUsers         ::</span> f <span class="dt">UserT</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>                      ,<span class="ot"> _shoppingCartUserAddresses ::</span> f <span class="dt">AddressT</span>}</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>                        <span class="kw">deriving</span> <span class="dt">Generic</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Database</span> <span class="dt">ShoppingCartDb</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a><span class="ot">shoppingCartDb ::</span> <span class="dt">DatabaseSettings</span> <span class="dt">ShoppingCartDb</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>shoppingCartDb <span class="ot">=</span> autoDbSettings</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span> beam <span class="ot">&lt;-</span> openDatabaseDebug shoppingCartDb <span class="dt">AutoMigrate</span> (<span class="dt">Sqlite3Settings</span> <span class="st">&quot;shoppingcart2.db&quot;</span>)</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>          dumpSchema shoppingCartDb <span class="co">-- Just to see what it's like</span></span></code></pre></div>
<p>Before we add addresses, we need to add some users that we can reference.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>          <span class="kw">let</span> [james, betty, sam] <span class="ot">=</span> [ <span class="dt">User</span> <span class="st">&quot;james@example.com&quot;</span> <span class="st">&quot;James&quot;</span> <span class="st">&quot;Smith&quot;</span> <span class="st">&quot;b4cc344d25a2efe540adbf2678e2304c&quot;</span> <span class="co">{- james -}</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>                                    , <span class="dt">User</span> <span class="st">&quot;betty@example.com&quot;</span> <span class="st">&quot;Betty&quot;</span> <span class="st">&quot;Jones&quot;</span> <span class="st">&quot;82b054bd83ffad9b6cf8bdb98ce3cc2f&quot;</span> <span class="co">{- betty -}</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>                                    , <span class="dt">User</span> <span class="st">&quot;sam@example.com&quot;</span> <span class="st">&quot;Sam&quot;</span> <span class="st">&quot;Taylor&quot;</span> <span class="st">&quot;332532dcfaa1cbf61e2a266bd723612c&quot;</span> <span class="co">{- sam -}</span> ]</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>          beamTxn beam <span class="op">$</span> \(<span class="dt">ShoppingCartDb</span> usersT userAddressesT) <span class="ot">-&gt;</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>              <span class="fu">mapM_</span> (insertInto usersT) [james, betty, sam]</span></code></pre></div>
<p>Now that we have some <code>User</code> objects, we can create associated addresses. Let’s give James one
address, Betty two addresses, and Sam none.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>          <span class="kw">let</span> addresses <span class="ot">=</span> [ <span class="dt">Address</span> <span class="dt">UnassignedId</span> <span class="st">&quot;123 Little Street&quot;</span> <span class="dt">Nothing</span> <span class="st">&quot;Boston&quot;</span> <span class="st">&quot;MA&quot;</span> <span class="st">&quot;12345&quot;</span> (pk james)</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>                          , <span class="dt">Address</span> <span class="dt">UnassignedId</span> <span class="st">&quot;222 Main Street&quot;</span> (<span class="dt">Just</span> <span class="st">&quot;Ste 1&quot;</span>) <span class="st">&quot;Houston&quot;</span> <span class="st">&quot;TX&quot;</span> <span class="st">&quot;8888&quot;</span> (pk betty)</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>                          , <span class="dt">Address</span> <span class="dt">UnassignedId</span> <span class="st">&quot;9999 Residence Ave&quot;</span> <span class="dt">Nothing</span> <span class="st">&quot;Sugarland&quot;</span> <span class="st">&quot;TX&quot;</span> <span class="st">&quot;8989&quot;</span> (pk betty) ]</span></code></pre></div>
<p>Notice that we used the <code>pk</code> function to assign the reference to the <code>UserT</code> table. <code>pk</code> is a
synonym of the <code>primaryKey</code> function from the <code>Table</code> type class. It should be clear what’s going
on, but if it’s not, let’s ask GHCi.</p>
<pre><code>*NextSteps&gt; pk (User &quot;james@example.com&quot; &quot;James&quot; &quot;Smith&quot; &quot;b4cc344d25a2efe540adbf2678e2304c&quot; {- james -} :: User)
UserId &quot;james@example.com&quot;</code></pre>
<p>Notice also that we set <code>_addressId</code> to <code>UnassignedId</code>. As mentioned above, the <code>AutoId</code> type means
the addresses won’t have an id until they’re inserted into the database. This could be an issue if
we want to refer to the addresses in the future. After all, we cannot ask the database to search for
<code>UnassignedId</code>. Fortunately, the <code>insertInto</code> function returns the value of the newly inserted
row. We can use this to get the id assigned to the <code>Address</code>.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>          <span class="dt">Success</span> [jamesAddress1, bettyAddress1, bettyAddress2] <span class="ot">&lt;-</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>              beamTxn beam <span class="op">$</span> \(<span class="dt">ShoppingCartDb</span> usersT userAddressesT) <span class="ot">-&gt;</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>                  <span class="fu">mapM</span> (insertInto userAddressesT) addresses</span></code></pre></div>
<p>Now we can print out the addresses to see that they were indeed assigned an id.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>          <span class="fu">putStrLn</span> <span class="st">&quot;The inserted addresses are:&quot;</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>          <span class="fu">mapM_</span> (<span class="fu">putStrLn</span> <span class="op">.</span> <span class="fu">show</span>) [jamesAddress1, bettyAddress1, bettyAddress2]</span></code></pre></div>
<p>You should see output like the following, confirming that the addresses were assigned an id.</p>
<pre><code>The inserted addresses are:
Address {_addressId = AssignedId 1, _addressLine1 = &quot;123 Little Street&quot;, _addressLine2 = Nothing, _addressCity = &quot;Boston&quot;, _addressState = &quot;MA&quot;, _addressZip = &quot;12345&quot;, _addressForUser = UserId &quot;james@example.com&quot;}
Address {_addressId = AssignedId 2, _addressLine1 = &quot;222 Main Street&quot;, _addressLine2 = Just &quot;Ste 1&quot;, _addressCity = &quot;Houston&quot;, _addressState = &quot;TX&quot;, _addressZip = &quot;8888&quot;, _addressForUser = UserId &quot;betty@example.com&quot;}
Address {_addressId = AssignedId 3, _addressLine1 = &quot;9999 Residence Ave&quot;, _addressLine2 = Nothing, _addressCity = &quot;Sugarland&quot;, _addressState = &quot;TX&quot;, _addressZip = &quot;8989&quot;, _addressForUser = UserId &quot;betty@example.com&quot;}</code></pre>
<h2 id="a-note-about-queries">A note about queries</h2>
<p>In the last tutorial, we saw how queries and list supported similar interfaces. Namely we saw how
<code>limit_</code> is like <code>take</code>, <code>offset_</code> like <code>drop</code>, <code>orderBy</code> like an enhanced <code>sortBy</code>, and <code>aggregate</code>
like an enhanced <code>groupBy</code>. This corresponded to the <code>LIMIT</code>, <code>OFFSET</code>, <code>ORDER BY</code>, and <code>GROUP BY</code>
SQL constructs. The missing SQL operation in this list is the <code>JOIN</code>, which computes the cartesian
product of two tables. In other words, a join between table <code>A</code> and table <code>B</code> results in a query of
pairs <code>(x, y)</code> for every <code>x</code> in <code>A</code> and every <code>y</code> in <code>B</code>. SQL joins can result in two-way,
three-way, four-way, etc. cartesian products.</p>
<p>Those familiar with lists in Haskell will note that there is an easy construct for taking n-ary
cartesian products over lists: the monad.</p>
<h3 id="the-list-monad">The list monad</h3>
<p>If we open GHCi, we can see this construct in action. Type the following into GHCi</p>
<pre><code>*NextSteps&gt; do { x &lt;- [1,2,3]; y &lt;- [4,5,6]; return (x, y); }
[(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]</code></pre>
<p>We get the two-way cartesian product of <code>[1,2,3]</code> and <code>[4,5,6]</code>. We can make the product arbitrarily long.</p>
<pre><code>*NextSteps&gt; do { w &lt;- [10, 20, 30]; x &lt;- [1,2,3]; y &lt;- [4,5,6]; z &lt;- [100, 200, 1]; return (x, y, z, w); }
[(1,4,100,10),(1,4,200,10),(1,4,1,10),(1,5,100,10),(1,5,200,10),(1,5,1,10), ... ]</code></pre>
<p>We can also use <code>guard</code> from <code>Control.Monad</code> to limit the combinations that the list monad puts
together. For example, if we had the lists</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> usersList <span class="ot">=</span> [(<span class="dv">1</span>, <span class="st">&quot;james&quot;</span>), (<span class="dv">2</span>, <span class="st">&quot;betty&quot;</span>), (<span class="dv">3</span>, <span class="st">&quot;tom&quot;</span>)]</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>    addressesList <span class="ot">=</span> [(<span class="dv">1</span>, <span class="st">&quot;address1&quot;</span>), (<span class="dv">1</span>, <span class="st">&quot;address2&quot;</span>), (<span class="dv">3</span>, <span class="st">&quot;address3&quot;</span>)]</span></code></pre></div>
<p>We can use <code>guard</code> to return all pairs of elements from <code>usersList</code> and <code>addressesList</code> that matched on their first
element. For example,</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="dt">NextSteps</span><span class="op">&gt;</span> <span class="kw">do</span> { user <span class="ot">&lt;-</span> usersList; address <span class="ot">&lt;-</span> addressesList; guard (<span class="fu">fst</span> user <span class="op">==</span> <span class="fu">fst</span> address); <span class="fu">return</span> (user, address) }</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>[((<span class="dv">1</span>,<span class="st">&quot;james&quot;</span>),(<span class="dv">1</span>,<span class="st">&quot;address1&quot;</span>)),((<span class="dv">1</span>,<span class="st">&quot;james&quot;</span>),(<span class="dv">1</span>,<span class="st">&quot;address2&quot;</span>)),((<span class="dv">3</span>,<span class="st">&quot;tom&quot;</span>),(<span class="dv">3</span>,<span class="st">&quot;address3&quot;</span>))]</span></code></pre></div>
<h3 id="the-query-monad">The query monad</h3>
<p>As I claimed in the first tutorial, queries support many of the same interfaces and operations lists
do. It follows that queries also expose a monadic interface.</p>
<p>For example, to retrieve every pair of user and address, we can write the following query:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>          <span class="fu">putStrLn</span> <span class="st">&quot;All pairs of users and addresses&quot;</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>          <span class="dt">Success</span> allPairs <span class="ot">&lt;-</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>              beamTxn beam <span class="op">$</span> \(<span class="dt">ShoppingCartDb</span> usersT addressesT) <span class="ot">-&gt;</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>                queryList <span class="op">$</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>                <span class="kw">do</span> user <span class="ot">&lt;-</span> all_ usersT</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>                   address <span class="ot">&lt;-</span> all_ addressesT</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>                   <span class="fu">return</span> (user, address)</span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>          <span class="fu">mapM_</span> (<span class="fu">putStrLn</span> <span class="op">.</span> <span class="fu">show</span>) allPairs</span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>          <span class="fu">putStrLn</span> <span class="st">&quot;----\n\n&quot;</span></span></code></pre></div>
<p>You’ll get output like the following</p>
<pre><code>Will execute SELECT `t0`.`email`, `t0`.`first_name`, `t0`.`last_name`, `t0`.`password`, `t1`.`id`, `t1`.`line1`, `t1`.`line2`, `t1`.`city`, `t1`.`state`, `t1`.`zip`, `t1`.`for_user__email` FROM  cart_users AS t0 INNER JOIN cart_user_addresses AS t1 with []
(User {_userEmail = &quot;james@example.com&quot;, _userFirstName = &quot;James&quot;, _userLastName = &quot;Smith&quot;, _userPassword = &quot;b4cc344d25a2efe540adbf2678e2304c&quot;},Address {_addressId = AssignedId 1, _addressLine1 = &quot;123 Little Street&quot;, _addressLine2 = Nothing, _addressCity = &quot;Boston&quot;, _addressState = &quot;MA&quot;, _addressZip = &quot;12345&quot;, _addressForUser = UserId &quot;james@example.com&quot;})
(User {_userEmail = &quot;james@example.com&quot;, _userFirstName = &quot;James&quot;, _userLastName = &quot;Smith&quot;, _userPassword = &quot;b4cc344d25a2efe540adbf2678e2304c&quot;},Address {_addressId = AssignedId 2, _addressLine1 = &quot;222 Main Street&quot;, _addressLine2 = Just &quot;Ste 1&quot;, _addressCity = &quot;Houston&quot;, _addressState = &quot;TX&quot;, _addressZip = &quot;8888&quot;, _addressForUser = UserId &quot;betty@example.com&quot;})
...
----</code></pre>
<p>Just like with lists we can also use a construct similar to guard to ensure that we only retrieve
users and addresses that are related. The <code>guard_</code> function takes in expression of type <code>QExpr s Bool</code>
which represents a SQL expression that returns a boolean. <code>QExpr s Bool</code>s support all the common
operators we have on regular <code>Bool</code>, except they’re suffixed with a <code>.</code>. For example, where you’d
use <code>(&amp;&amp;)</code> on two Haskell-level <code>Bool</code>s, we’d use <code>(&amp;&amp;.)</code> on <code>QExpr</code>-level bools.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>          <span class="fu">putStrLn</span> <span class="st">&quot;All pairs of users with their related addresses&quot;</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>          <span class="dt">Success</span> usersAndRelatedAddresses <span class="ot">&lt;-</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>              beamTxn beam <span class="op">$</span> \(<span class="dt">ShoppingCartDb</span> usersT addressesT) <span class="ot">-&gt;</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>                  queryList <span class="op">$</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">do</span> user<span class="op">@</span>(<span class="dt">User</span> { _userEmail <span class="ot">=</span> userEmail }) <span class="ot">&lt;-</span> all_ usersT</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>                     address<span class="op">@</span>(<span class="dt">Address</span> {_addressForUser <span class="ot">=</span> <span class="dt">UserId</span> addressForUser}) <span class="ot">&lt;-</span> all_ addressesT</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>                     guard_ (addressForUser <span class="op">==.</span> userEmail)</span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>                     <span class="fu">pure</span> (user, address)</span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>          <span class="fu">mapM_</span> (<span class="fu">putStrLn</span> <span class="op">.</span> <span class="fu">show</span>) usersAndRelatedAddresses</span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>          <span class="fu">putStrLn</span> <span class="st">&quot;----\n\n&quot;</span></span></code></pre></div>
<p>The output for this query is</p>
<pre><code>Will execute SELECT `t0`.`email`, `t0`.`first_name`, `t0`.`last_name`, `t0`.`password`, `t1`.`id`, `t1`.`line1`, `t1`.`line2`, `t1`.`city`, `t1`.`state`, `t1`.`zip`, `t1`.`for_user__email` FROM  cart_users AS t0 INNER JOIN cart_user_addresses AS t1 WHERE `t1`.`for_user__email` == `t0`.`email` with []
(User {_userEmail = &quot;james@example.com&quot;, _userFirstName = &quot;James&quot;, _userLastName = &quot;Smith&quot;, _userPassword = &quot;b4cc344d25a2efe540adbf2678e2304c&quot;},Address {_addressId = AssignedId 1, _addressLine1 = &quot;123 Little Street&quot;, _addressLine2 = Nothing, _addressCity = &quot;Boston&quot;, _addressState = &quot;MA&quot;, _addressZip = &quot;12345&quot;, _addressForUser = UserId &quot;james@example.com&quot;})
(User {_userEmail = &quot;betty@example.com&quot;, _userFirstName = &quot;Betty&quot;, _userLastName = &quot;Jones&quot;, _userPassword = &quot;82b054bd83ffad9b6cf8bdb98ce3cc2f&quot;},Address {_addressId = AssignedId 2, _addressLine1 = &quot;222 Main Street&quot;, _addressLine2 = Just &quot;Ste 1&quot;, _addressCity = &quot;Houston&quot;, _addressState = &quot;TX&quot;, _addressZip = &quot;8888&quot;, _addressForUser = UserId &quot;betty@example.com&quot;})
(User {_userEmail = &quot;betty@example.com&quot;, _userFirstName = &quot;Betty&quot;, _userLastName = &quot;Jones&quot;, _userPassword = &quot;82b054bd83ffad9b6cf8bdb98ce3cc2f&quot;},Address {_addressId = AssignedId 3, _addressLine1 = &quot;9999 Residence Ave&quot;, _addressLine2 = Nothing, _addressCity = &quot;Sugarland&quot;, _addressState = &quot;TX&quot;, _addressZip = &quot;8989&quot;, _addressForUser = UserId &quot;betty@example.com&quot;})</code></pre>
<p>Of course this is kind of messy because it involves manually matching the primary key of <code>User</code> with
the reference in <code>Address</code>. Alternatively, we can use the <code>references_</code> combinator to have Beam
automatically generate a <code>QExpr</code> expression that can match primary keys together.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>          <span class="fu">putStrLn</span> <span class="st">&quot;All pairs of users with their related addresses (using references_)&quot;</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>          <span class="dt">Success</span> usersAndRelatedAddressesUsingReferences <span class="ot">&lt;-</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>              beamTxn beam <span class="op">$</span> \(<span class="dt">ShoppingCartDb</span> usersT addressesT) <span class="ot">-&gt;</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>                  queryList <span class="op">$</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">do</span> user <span class="ot">&lt;-</span> all_ usersT</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>                     address <span class="ot">&lt;-</span> all_ addressesT</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>                     guard_ (_addressForUser address <span class="ot">`references_`</span> user)</span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>                     <span class="fu">pure</span> (user, address)</span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a>          <span class="fu">mapM_</span> (<span class="fu">putStrLn</span> <span class="op">.</span> <span class="fu">show</span>) usersAndRelatedAddressesUsingReferences</span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a>          <span class="fu">putStrLn</span> <span class="st">&quot;----\n\n&quot;</span></span></code></pre></div>
<p>The debug output shows that we get the same query and same output as above.</p>
<p>You may have noticed that the joins up until now did not include a SQL <code>ON</code> clause. Instead we
joined the tables together, and then used the <code>WHERE</code> clause to filter out results we don’t want. If
you’d like to use the <code>ON</code> clause to make the SQL clearer or save a line in your code, beam offers
the <code>related_</code> combinator to pull related tables directly into the query monad.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>          <span class="fu">putStrLn</span> <span class="st">&quot;All pairs of users with their related addresses (using related_)&quot;</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>          <span class="dt">Success</span> usersAndRelatedAddressesUsingRelated <span class="ot">&lt;-</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>              beamTxn beam <span class="op">$</span> \(<span class="dt">ShoppingCartDb</span> usersT addressesT) <span class="ot">-&gt;</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>                  queryList <span class="op">$</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">do</span> address <span class="ot">&lt;-</span> all_ addressesT</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>                     user <span class="ot">&lt;-</span> related_ usersT (_addressForUser address)</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>                     <span class="fu">pure</span> (user, address)</span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>          <span class="fu">mapM_</span> (<span class="fu">putStrLn</span> <span class="op">.</span> <span class="fu">show</span>) usersAndRelatedAddressesUsingRelated</span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>          <span class="fu">putStrLn</span> <span class="st">&quot;----\n\n&quot;</span></span></code></pre></div>
<p>The output shows us that the correct <code>ON</code> clause has been generated, and you can verify that the
results are the same.</p>
<pre><code>Will execute SELECT `t1`.`email`, `t1`.`first_name`, `t1`.`last_name`, `t1`.`password`, `t0`.`id`, `t0`.`line1`, `t0`.`line2`, `t0`.`city`, `t0`.`state`, `t0`.`zip`, `t0`.`for_user__email` FROM  cart_user_addresses AS t0 INNER JOIN cart_users AS t1 ON `t0`.`for_user__email` == `t1`.`email` with []
...
----</code></pre>
<p>We can also query the addresses for a particular user given a <code>UserId</code>.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- This is a contrived example to show how we can use an arbitrary UserId to fetch a particular user.</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- We don't always have access to the full 'User' lying around. For example we may be in a function that</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- only accepts 'UserId's.</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>          <span class="kw">let</span> bettyId <span class="ot">=</span> <span class="dt">UserId</span> <span class="st">&quot;betty@example.com&quot;</span><span class="ot"> ::</span> <span class="dt">UserId</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>          <span class="fu">putStrLn</span> <span class="st">&quot;All addresses for 'betty@example.com'&quot;</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>          <span class="dt">Success</span> bettysAddresses <span class="ot">&lt;-</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>              beamTxn beam <span class="op">$</span> \(<span class="dt">ShoppingCartDb</span> usersT addressesT) <span class="ot">-&gt;</span></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>                 queryList <span class="op">$</span></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">do</span> address <span class="ot">&lt;-</span> all_ addressesT</span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a>                     guard_ (_addressForUser address <span class="op">==.</span> val_ bettyId)</span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a>                     <span class="fu">pure</span> address</span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a>          <span class="fu">mapM_</span> (<span class="fu">putStrLn</span> <span class="op">.</span> <span class="fu">show</span>) bettysAddresses</span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a>          <span class="fu">putStrLn</span> <span class="st">&quot;----\n\n&quot;</span></span></code></pre></div>
<p>Again the correct SQL and results are generated.</p>
<pre><code>Will execute SELECT `t0`.`id`, `t0`.`line1`, `t0`.`line2`, `t0`.`city`, `t0`.`state`, `t0`.`zip`, `t0`.`for_user__email` FROM  cart_user_addresses AS t0 WHERE `t0`.`for_user__email` == ? with [SqlString &quot;betty@example.com&quot;]
Address {_addressId = AssignedId 2, _addressLine1 = &quot;222 Main Street&quot;, _addressLine2 = Just &quot;Ste 1&quot;, _addressCity = &quot;Houston&quot;, _addressState = &quot;TX&quot;, _addressZip = &quot;8888&quot;, _addressForUser = UserId &quot;betty@example.com&quot;}
Address {_addressId = AssignedId 3, _addressLine1 = &quot;9999 Residence Ave&quot;, _addressLine2 = Nothing, _addressCity = &quot;Sugarland&quot;, _addressState = &quot;TX&quot;, _addressZip = &quot;8989&quot;, _addressForUser = UserId &quot;betty@example.com&quot;}
----</code></pre>
<h2 id="updates-and-deletions">Updates and deletions</h2>
<p>So far we’ve only seen how to insert data and query it. There are two other SQL operations that we
have not covered: updates and deletions. Beam has full support for these manipulations as well.</p>
<p>There are four functions that we’re interested in: <code>save</code>, <code>updateWhere</code>, <code>deleteFrom</code>, and
<code>deleteWhere</code>. Let’s look at their type signatures to see how they work.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="ot">save ::</span> (<span class="dt">MonadIO</span> m, <span class="dt">Table</span> tbl) <span class="ot">=&gt;</span> <span class="dt">DatabaseTable</span> db tbl <span class="ot">-&gt;</span> tbl <span class="dt">Identity</span> <span class="ot">-&gt;</span> <span class="dt">BeamT</span> db m ()</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="ot">updateWhere ::</span> (<span class="dt">MonadIO</span> m, <span class="dt">Table</span> tbl) <span class="ot">=&gt;</span> <span class="dt">DatabaseTable</span> db tbl <span class="ot">-&gt;</span> (tbl (<span class="dt">QExpr</span> s) <span class="ot">-&gt;</span> tbl <span class="dt">SetExpr</span>) <span class="ot">-&gt;</span> (tbl (<span class="dt">QExpr</span> s) <span class="ot">-&gt;</span> <span class="dt">QExpr</span> s <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">BeamT</span> db m ()</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a><span class="ot">deleteFrom ::</span> (<span class="dt">MonadIO</span> m, <span class="dt">Table</span> tbl) <span class="ot">=&gt;</span> <span class="dt">DatabaseTable</span> db tbl <span class="ot">-&gt;</span> tbl <span class="dt">Identity</span> <span class="ot">-&gt;</span> <span class="dt">BeamT</span> db m ()</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a><span class="ot">deleteWhere ::</span> (<span class="dt">MonadIO</span> m, <span class="dt">Table</span> tbl) <span class="ot">=&gt;</span> <span class="dt">DatabaseTable</span> db tbl <span class="ot">-&gt;</span> (tbl (<span class="dt">QExpr</span> s) <span class="ot">-&gt;</span> <span class="dt">QExpr</span> s <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">BeamT</span> db m ()</span></code></pre></div>
<p>Note that in the declarations above <code>QExpr</code> is the type of all expressions allowed in SQL, and the
<code>s</code> parameter is a threading parameter that prevents <code>QExpr</code>s from being used in inappropriate
contexts, similar to how the <code>s</code> in <code>ST s</code> allows you to use mutable data in a pure fashion.</p>
<h3 id="updates">Updates</h3>
<p>Let’s first look at updating passwords given a <code>User</code>. For this we can use the <code>saveTo</code>
function. Suppose James wants to change his password to the md5 hash of “supersecure”, which is
<code>52a516ca6df436828d9c0d26e31ef704</code>. We have a <code>User</code> object representing James so we can simply call
<code>saveTo</code> on the update value to update the corresponding record in the database.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>          <span class="fu">putStrLn</span> <span class="st">&quot;Updating james' password&quot;</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>          beamTxn beam <span class="op">$</span> \(<span class="dt">ShoppingCartDb</span> usersT addressesT) <span class="ot">-&gt;</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>              saveTo usersT (james { _userPassword <span class="ot">=</span> <span class="st">&quot;52a516ca6df436828d9c0d26e31ef704&quot;</span> })</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>          <span class="dt">Success</span> newPassword <span class="ot">&lt;-</span> beamTxn beam <span class="op">$</span> \(<span class="dt">ShoppingCartDb</span> usersT addressesT) <span class="ot">-&gt;</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>                                 getOne <span class="op">$</span> <span class="kw">do</span> james <span class="ot">&lt;-</span> lookup_ usersT (val_ (<span class="dt">UserId</span> <span class="st">&quot;james@example.com&quot;</span><span class="ot"> ::</span> <span class="dt">UserId</span>))</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>                                             <span class="fu">return</span> (_userPassword james)</span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>          <span class="fu">putStrLn</span> (<span class="st">&quot;Verified that james's new password is &quot;</span> <span class="op">++</span> <span class="fu">show</span> newPassword)</span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>          <span class="fu">putStrLn</span> <span class="st">&quot;----\n&quot;</span></span></code></pre></div>
<p>When this runs, you’ll see that the password pulled from the database matches the one we just saved.</p>
<pre><code>Updating james' password
Will execute UPDATE cart_users SET email=?, first_name=?, last_name=?, password=? WHERE email == ? with [SqlString &quot;james@example.com&quot;,SqlString &quot;James&quot;,SqlString &quot;Smith&quot;,SqlString &quot;52a516ca6df436828d9c0d26e31ef704&quot;,SqlString &quot;james@example.com&quot;]
Will execute SELECT `t0`.`password` FROM  cart_users AS t0 WHERE ? == `t0`.`email` with [SqlString &quot;james@example.com&quot;]
Verified that james's new password is Just &quot;52a516ca6df436828d9c0d26e31ef704&quot;</code></pre>
<p>This works great, but <code>saveTo</code> requires that we have the whole <code>User</code> object at our
disposal. Additionally, you’ll notice that it causes every field to be set in the <code>UPDATE</code>
query. Typically, this doesn’t matter, but sometimes we’d like to update fewer fields, multiple
rows, or use criteria other than a primary key match. The <code>updateWhere</code> function offers us the full
functionality of SQL <code>UPDATE</code>s.</p>
<p>To illustrate use of this function, let’s suppose the city of “Sugarland, TX” was renamed
“Sugarville, TX” and had its ZIP code changed to be “12345” citywide. The following beam command
will update all addresses in the old city to use the new name and ZIP code.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>          beamTxn beam <span class="op">$</span> \(<span class="dt">ShoppingCartDb</span> usersT addressesT) <span class="ot">-&gt;</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>              updateWhere addressesT (\address <span class="ot">-&gt;</span> address { _addressCity <span class="ot">=</span> val_ <span class="st">&quot;Sugarville&quot;</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>                                                          , _addressZip  <span class="ot">=</span> val_ <span class="st">&quot;12345&quot;</span> })</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>                                     (\address <span class="ot">-&gt;</span> _addressCity address <span class="op">==.</span> val_ <span class="st">&quot;Sugarland&quot;</span> <span class="op">&amp;&amp;.</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>                                                  _addressState address <span class="op">==.</span> val_ <span class="st">&quot;TX&quot;</span>)</span></code></pre></div>
<p>This will execute the expected <code>UPDATE</code> statement</p>
<pre><code>Will execute UPDATE cart_user_addresses SET city=?, zip=? WHERE city == ? AND state == ? with [SqlString &quot;Sugarville&quot;,SqlString &quot;12345&quot;,SqlString &quot;Sugarland&quot;,SqlString &quot;TX&quot;]</code></pre>
<p>We can confirm that the address was updated by reading back the database’s version of Betty’s second
address.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>          <span class="fu">putStrLn</span> <span class="st">&quot;\nChecking betty's second address to ensure it's updated to Sugarville, TX&quot;</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>          <span class="dt">Success</span> address <span class="ot">&lt;-</span> beamTxn beam <span class="op">$</span> \(<span class="dt">ShoppingCartDb</span> usersT addressesT) <span class="ot">-&gt;</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>                             getOne (lookup_ addressesT (val_ (primaryKey bettyAddress2)))</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>          <span class="fu">putStrLn</span> (<span class="st">&quot;Got new address &quot;</span> <span class="op">++</span> <span class="fu">show</span> address <span class="op">++</span> <span class="st">&quot;\n&quot;</span>)</span></code></pre></div>
<h3 id="deletions">Deletions</h3>
<p>Now suppose that Betty has decided to give up her place in Houston. We can use the <code>delete</code> function
to remove a row if we have that row’s primary key.</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>          <span class="fu">putStrLn</span> <span class="st">&quot;Deleting betty's first address&quot;</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>          beamTxn beam <span class="op">$</span> \(<span class="dt">ShoppingCartDb</span> usersT addressesT) <span class="ot">-&gt;</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>              deleteFrom addressesT (pk bettyAddress1)</span></code></pre></div>
<p>Beam executes an appropriate <code>DELETE</code> statement, using the primary key to reference the table.</p>
<pre><code>Deleting betty's first address
Will execute DELETE FROM cart_user_addresses WHERE id == ? with [SqlInteger 2]</code></pre>
<p>Just for fun, let’s remove all users named Sam. After all, they don’t have any addresses stored!</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>          <span class="fu">putStrLn</span> <span class="st">&quot;Deleting Sam&quot;</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>          beamTxn beam <span class="op">$</span> \(<span class="dt">ShoppingCartDb</span> usersT addressesT) <span class="ot">-&gt;</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>              deleteWhere usersT (\user <span class="ot">-&gt;</span> _userFirstName user <span class="op">==.</span> val_ <span class="st">&quot;Sam&quot;</span>)</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>          <span class="fu">pure</span> ()</span></code></pre></div>
<p>Again, beam produces the SQL we’d expect</p>
<pre><code>Deleting Sam
Will execute DELETE FROM cart_users WHERE first_name == ? with [SqlString &quot;Sam&quot;]</code></pre>
<h2 id="conclusion">Conclusion</h2>
<p>In this tutorial we created our first beam relationship. We saw how to use <code>tableConfigLenses</code> and
the <code>microlens</code> library to change the default storage options beam chose for us. We used the monadic
tquery interface to write queries that used SQL joins, and we saw how beam makes it easy to
tautomatically pull related tables into our queries. Finally we used the <code>updateWhere</code>, <code>saveTo</code>,
<code>deleteWhere</code>, and <code>deleteFrom</code> functions to update and delete rows in our tables.</p>
<p>At this point, we’ve covered enough of the beam interface to start writing interesting
programs. Take some time to explore beam and create your own databases. For more information on the
Beam Query API, including all the combinators you can use for <code>QExpr</code>s, see the haddock
documentation for <code>Database.Beam.Query</code>. If you’re interested in all the different field types
supported by Beam, see the module source for <code>Database.Beam.Fields</code>.</p>
<p>Until next time!</p>
<p>As always, if you have any questions, feel free to e-mail me at travis@athougies.net. Bugs and
patches should go to <a href="https://github.com/tathougies/beam">GitHub</a>.</p>
</div>

<div id="disqus_thread"></div>
<script type="text/javascript">
/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
var disqus_shortname = 'travisathougiessblog'; // required: replace example with your forum shortname

/* * * DON'T EDIT BELOW THIS LINE * * */
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

        </div>
        <!-- Google Analytics Tracking -->
        <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-55204994-1', 'auto');
        ga('send', 'pageview');

        </script>
    </body>
</html>
